<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++三大概念要分清--重载，隐藏（重定义），覆盖（重写）</title>
    <link href="/2024/01/15/c-%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5%E8%A6%81%E5%88%86%E6%B8%85-%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89/"/>
    <url>/2024/01/15/c-%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5%E8%A6%81%E5%88%86%E6%B8%85-%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/10292417.html">https://www.cnblogs.com/linuxAndMcu/p/10292417.html</a></p></blockquote><h1 id="c-三大概念要分清–重载，隐藏（重定义），覆盖（重写）"><a href="#c-三大概念要分清–重载，隐藏（重定义），覆盖（重写）" class="headerlink" title="c++三大概念要分清–重载，隐藏（重定义），覆盖（重写）"></a>c++三大概念要分清–重载，隐藏（重定义），覆盖（重写）</h1><img src="/2024/01/15/c-%E4%B8%89%E5%A4%A7%E6%A6%82%E5%BF%B5%E8%A6%81%E5%88%86%E6%B8%85-%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%9A%90%E8%97%8F%EF%BC%88%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%89%EF%BC%8C%E8%A6%86%E7%9B%96%EF%BC%88%E9%87%8D%E5%86%99%EF%BC%89/1.png" class=""><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ol><li><p>概念：在同一个作用域内；函数名相同，参数列表不同（参数<strong>个数不同</strong>，或者<strong>参数类型不同</strong>，或者<strong>参数个数和参数类型都不同</strong>），返回值类型可相同也可不同；这种情况叫做c++的重载！</p></li><li><p>特征：</p></li></ol><ul><li>在同一作用域（例如在同一个类中）；</li><li>函数名字相同；</li><li>参数列表不同。</li></ul><ol start="3"><li>重载达到的效果：</li></ol><p><strong>调用函数名相同的函数，会根据实参的类型和实参顺序以及实参个数选择相应的函数。</strong> C++ 函数重载是一种静态多态（又叫做静态联编，静态绑定）。</p><ol start="4"><li>举例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">float</span> a, <span class="hljs-type">float</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">Add</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>) &lt;&lt; endl; <span class="hljs-comment">// 调用 int Add(int a,int b)</span><br>cout &lt;&lt; <span class="hljs-built_in">Add</span>(<span class="hljs-number">2.5f</span>, <span class="hljs-number">3.7f</span>) &lt;&lt; endl; <span class="hljs-comment">// 调用 float Add(float a,float b)</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">9</span><br><span class="hljs-comment">6.2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>此时，两个函数<code>Add()</code>;在同一作用域，函数名相同都是 <code>Add</code>，参数类型不同，就构成了 <code>C++</code>中的函数重载。</li></ol><h2 id="覆盖（又叫重写）"><a href="#覆盖（又叫重写）" class="headerlink" title="覆盖（又叫重写）"></a>覆盖（又叫重写）</h2><ol><li><p>概念：当在子类中定义了一个与父类<strong>完全相同</strong>的虚函数时，则称子类的这个<strong>函数重写（也称覆盖）</strong> 了父类的这个虚函数。</p></li><li><p>覆盖：</p></li></ol><ul><li>不同的作用域（分别位于派生类与基类）；</li><li>函数名字相同；</li><li>参数相同；</li><li>基类函数必须有virtual关键字。</li></ul><ol start="3"><li>什么是在子类中定义了一个与父类完全相同的虚函数：</li></ol><p>有两种情况：</p><ul><li>就是说子类中的虚函数和父类中的虚函数，<strong>函数名，参数个数，参数类型，返回值类型都相同</strong>；这种情况下子类的这个虚函数重写的父类中的虚函数，构成了重写。</li><li>协变—是说子类中的虚函数和父类中的虚函数，<strong>函数名，参数个数，参数类型都相同，只是返回值类型不同</strong>；父类的虚函数返回父类的指针或者引用，子类虚函数返回子类的指针或者引用；这种情况下子类的这个虚函数也重写了父类中的虚函数，也构成了重写；——我们把这种特殊的情况叫做<strong>协变</strong>。</li></ul><ol start="4"><li>覆盖（重写）达到的效果：</li></ol><ul><li><strong>在子类中重写了父类的虚函数，那么子类对象调用该重写函数，调用到的是子类内部重写的虚函数，而并不是从父类继承下来的虚函数；（这其实就是动态多态的实现）</strong>；</li><li>在子类中重写了父类的虚函数，<strong>如果用一个父类的指针（或引用）指向（或引用）子类对象，那么这个父类的指针或引用将调用该子类重写的虚函数；相反，如果用一个父类的指针（或引用）指向（或引用）父类的对象，那么这个父类的指针（或引用）将调用父类的虚函数。</strong></li></ul><ol start="5"><li>举例一：普通重写<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 普通重写+函数重载</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-comment">// 父类虚函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Class Base!\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-comment">// 子类1虚函数，重写了父类的虚函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Class Derived!\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base Cbase; <span class="hljs-comment">// 父类对象</span><br>Derived Cderived; <span class="hljs-comment">// 子类对象</span><br>Cbase.<span class="hljs-built_in">Print</span>();<br>Cderived.<span class="hljs-built_in">Print</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------&quot;</span> &lt;&lt; endl;<br>    Base *p1 = &amp;Cderived; <span class="hljs-comment">// 父类指针指向子类对象 </span><br>Base *p2 = &amp;Cbase; <span class="hljs-comment">// 父类指针指向父类对象</span><br>p1-&gt;<span class="hljs-built_in">Print</span>(); <br>p2-&gt;<span class="hljs-built_in">Print</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">This is Class Base!</span><br><span class="hljs-comment">This is Class Derived!</span><br><span class="hljs-comment">---------------</span><br><span class="hljs-comment">This is Class Derived!</span><br><span class="hljs-comment">This is Class Base!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li>举例二：协变重写<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// （协变）重写+函数重载</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> Base &amp;<span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-comment">// 父类虚函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Class Base!\n&quot;</span>);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Derived &amp;<span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-comment">// 子类虚函数，重写了父类的虚函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is Class Derived!\n&quot;</span>);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base Cbase;<br>Derived Cderived;<br>Cbase.<span class="hljs-built_in">Print</span>();<br>Cderived.<span class="hljs-built_in">Print</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------&quot;</span> &lt;&lt; endl;<br>Base *p1 = &amp;Cderived;<br>Base *p2 = &amp;Cbase;<br>p1-&gt;<span class="hljs-built_in">Print</span>();<br>p2-&gt;<span class="hljs-built_in">Print</span>();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">This is Class Base!</span><br><span class="hljs-comment">This is Class Derived!</span><br><span class="hljs-comment">---------------</span><br><span class="hljs-comment">This is Class Derived!</span><br><span class="hljs-comment">This is Class Base!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li>重载与覆盖(重写)有什么区别？</li></ol><ul><li>范围区别：重载的函数在同一类中，而重写的函数在不同的类（基类和派生类）中；</li><li>参数列表区别：重载要求参数列表不同，而覆盖要求参数列表相同；</li><li>virtual 的区别：重载函数和被重载函数可以被 virtual 修饰，也可以没有，而重写的基类函数必须要有 virtual 修饰；</li><li>调用方法不同：重载是根据调用时的实参列表来选择方法体的，而覆盖是根据对象的类型来决定的。</li></ul><h2 id="隐藏（重定义）"><a href="#隐藏（重定义）" class="headerlink" title="隐藏（重定义）"></a>隐藏（重定义）</h2><ol><li>概念：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</li></ol><ul><li>如果派生类的函数与基类的函数同名，并且<strong>参数也相同，但是基类函数没有 virtual 关键字，此时基类的函数才被隐藏。</strong></li><li>如果派生类的函数与基类的函数同名，但是<strong>参数不同，则不论有无 virtual 关键字， 基类的函数都将被隐藏。</strong></li></ul><p>在调用一个类的成员函数时，编译器会沿着类的继承链逐级地向上查找函数的定义，如果找到了就停止查找了。所以，<strong>如果一个派生类和一个基类都存在同名（暂且不论参数是否相同）的函数，而编译器最终选择了在派生类中的函数，那么就说这个派生类的成员函数“隐藏”了基类的成员函数，也就是说它阻止了编译器继续向上查找函数的定义。</strong></p><ol start="2"><li>特征：</li></ol><ul><li>必须分别位于派生类和基类中；</li><li>必须同名；</li><li>参数不同的时候本身已经不构成覆盖关系了，所以此时是否是 virtual 函数已经不重要了。</li></ul><ol start="3"><li>隐藏（重定义）的使用范围：</li></ol><p>隐藏的<strong>不光是类的成员函数，还可以是类的成员变量；</strong></p><ol start="4"><li>隐藏（重定义）的直接效果：</li></ol><ul><li>如果在父类和子类中有相同名字的成员，那么在子类中，会将父类的成员隐藏；隐藏以后的直接效果就是：<strong>无论在子类的内部或者外部（通过子类成员）访问该成员；全都是访问子类的同名成员。</strong></li><li><strong>如果用一个父类的指针（或引用）指向（或引用）子类对象，那么这个父类的指针或引用将调用父类的同名函数；</strong></li></ul><ol start="5"><li>举例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>) :<span class="hljs-built_in">value</span>(x) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print1</span><span class="hljs-params">()</span> <span class="hljs-comment">// 父类函数不是虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base Print1():&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print2</span><span class="hljs-params">()</span> <span class="hljs-comment">// 父类函数是虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base Print2():&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">2</span>) :<span class="hljs-built_in">value</span>(x) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print1</span><span class="hljs-params">()</span> <span class="hljs-comment">// 函数同名，且参数相同，同时父类函数不是虚函数，构成“隐藏”</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derived Print1():&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-comment">// 函数同名，但是参数不同，无论父类函数是不是虚函数，都构成“隐藏”</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derived Print2():&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>a = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> value; <span class="hljs-comment">// 子类成员数据，隐藏了子类的同名数据</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Derived Cderived;<br>cout &lt;&lt; Cderived.value &lt;&lt; endl; <span class="hljs-comment">// 调用子类的成员数据</span><br>Cderived.<span class="hljs-built_in">Print1</span>(); <span class="hljs-comment">// 隐藏</span><br>Cderived.<span class="hljs-built_in">Print2</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 隐藏</span><br><br>Base &amp;Cbase = Cderived; <span class="hljs-comment">// 父类的指针（或引用）指向（或引用）子类对象</span><br>Cbase.<span class="hljs-built_in">Print1</span>(); <span class="hljs-comment">// 将调用父类的同名函数（隐藏）</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">Derived Print1():2</span><br><span class="hljs-comment">Derived Print2():2</span><br><span class="hljs-comment">Base Print1():1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li>隐藏(重定义)与覆盖(重写)有什么区别？</li></ol><ul><li>virtual 的区别：隐藏的基类函数不需要用 virtual 修饰，而覆盖的基类函数必须要有 virtual 修饰；</li><li>参数列表区别：隐藏的基类和派生类的函数参数列表可以不同，而覆盖的基类和派生类的函数参数列表必须相同。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的四种强制类型转换符详解</title>
    <link href="/2024/01/15/C-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%A6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/01/15/C-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%A6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/10387829.html">https://www.cnblogs.com/linuxAndMcu/p/10387829.html</a></p></blockquote><h1 id="C-中的四种强制类型转换符详解"><a href="#C-中的四种强制类型转换符详解" class="headerlink" title="C++中的四种强制类型转换符详解"></a>C++中的四种强制类型转换符详解</h1><p>C++ 既支持 C 风格的类型转换，又有自己风格的类型转换。C 风格的转换格式很简单，但是有不少缺点：</p><ul><li>转换太过随意，可以在任意类型之间转换。你可以把一个指向 <code>const</code> 对象的指针转换成指向<code>非 const</code> 对象的指针，把一个指向基类对象的指针转换成一个派生类对象的指针，这些转换之间的差距是非常巨大的，但是传统的C语言风格的类型转换没有区分这些。</li><li>C 风格的转换没有统一的关键字和标示符。对于大型系统，做代码排查时容易遗漏和忽略。</li></ul><p>C++ 风格完美的解决了上面两个问题。</p><ul><li>对类型转换做了细分，提供了四种不同类型转换，以支持不同需求的转换；</li><li>类型转换有了统一的标示符，利于代码排查和检视。</li></ul><p>下面分别来介绍这四种转换：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>、<code>reinterpert_cast</code>，它们都是类模板。</p><p><strong>格式均为：<code>xx_cast&lt;type-id&gt;(expression)</code> ，其中<code>type-id</code>-要转换成什么类型，<code>expression</code>-被转换类型的目标变量</strong></p><h2 id="static-case-静态转换"><a href="#static-case-静态转换" class="headerlink" title="static_case(静态转换)"></a>static_case(静态转换)</h2><ol><li>使用场景</li></ol><ul><li>在基本数据类型之间转换，如把 int 转换为 char，这种带来安全性问题由程序员来保证；</li><li>在有类型指针与 void * 之间转换；</li><li>用于类层次结构中基类和派生类之间指针或引用的转换。</li><li><ul><li>上行转换（派生类—-&gt;基类）是安全的；</li></ul></li><li><ul><li>下行转换（基类—-&gt;派生类）由于没有动态类型检查，所以是不安全的。</li></ul></li></ul><ol start="2"><li>使用特点</li></ol><ul><li>主要执行非多态的转换操作，用于代替C中通常的转换操作。</li><li>隐式转换都建议使用 static_cast 进行标明和替换。</li><li>不能使用 static_cast 在有类型指针内转换。</li></ul><ol start="3"><li>示例程序如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBase</span> <span class="hljs-comment">// 基类(父类)</span><br>&#123;<br>    <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CDerived</span> : <span class="hljs-keyword">public</span> CBase  <span class="hljs-comment">// 派生类(子类)</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 使用static_cast在基本数据类型之间转换</span><br><span class="hljs-type">float</span> fval = <span class="hljs-number">10.12</span>;<br><span class="hljs-type">int</span> ival = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(fval);  <span class="hljs-comment">// float --&gt; int</span><br>cout &lt;&lt; ival &lt;&lt; endl;  <span class="hljs-comment">// out: 10</span><br><br><span class="hljs-comment">// 2. 使用static_cast在有类型指针与void *之间转换</span><br><span class="hljs-type">int</span> *intp = &amp;ival;<br><span class="hljs-type">void</span> *voidp = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span> *&gt;(intp); <span class="hljs-comment">// int* --&gt; void*</span><br><span class="hljs-comment">// cout &lt;&lt; *voidp &lt;&lt; endl; // error,voidp的大小未知</span><br><span class="hljs-type">long</span> *longp = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span> *&gt;(voidp);<br>cout &lt;&lt; *longp &lt;&lt; endl; <span class="hljs-comment">// out: 10</span><br><br><span class="hljs-comment">// 3. 用于类层次结构中基类和派生类之间指针或引用的转换</span><br><span class="hljs-comment">// 上行转换（派生类----&gt;基类）是安全的</span><br>CDerived *tCDerived1 = <span class="hljs-literal">nullptr</span>;<br>CBase *tCBase1 = <span class="hljs-built_in">static_cast</span>&lt;CBase*&gt;(tCDerived1);<br><span class="hljs-comment">// 下行转换（基类---- &gt; 派生类）由于没有动态类型检查，所以是不安全的</span><br>CBase *tCBase2 = <span class="hljs-literal">nullptr</span>;<br>CDerived *tCDerived2 = <span class="hljs-built_in">static_cast</span>&lt;CDerived*&gt;(tCBase2); <span class="hljs-comment">//不会报错，但是不安全</span><br><br><span class="hljs-comment">// 不能使用static_cast在有类型指针内转换</span><br><span class="hljs-type">float</span> *floatp = &amp;fval;  <span class="hljs-comment">//10.12的addr</span><br><span class="hljs-comment">//int *intp1 = static_cast&lt;int *&gt;(floatp); // error,不能使用static_cast在有类型指针内转换</span><br>cout &lt;&lt; *floatp &lt;&lt; endl;    <span class="hljs-comment">// out: 10.12</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">10</span><br><span class="hljs-comment">10.12</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="dynamic-cast-动态转换"><a href="#dynamic-cast-动态转换" class="headerlink" title="dynamic_cast(动态转换)"></a>dynamic_cast(动态转换)</h2><ol><li>使用场景</li></ol><ul><li>用于将一个父类的指针&#x2F;引用转化为子类的指针&#x2F;引用（下行转换）。</li></ul><ol start="2"><li>使用特点</li></ol><ul><li>基类必须要有虚函数，因为 <code>dynamic_cast</code> 是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中。</li><li>对于下行转换，<code>dynamic_cast</code> 是安全的（当类型不一致时，转换过来的是空指针），而 <code>static_cast</code> 是不安全的。</li><li>对指针进行 <code>dynamic_cast</code>，失败返回 <code>NULL</code>，成功返回正常 cast 后的对象指针；对引用进行 <code>dynamic_cast</code>，失败抛出一个异常，成功返回正常 cast 后的对象引用。</li></ul><ol start="3"><li>示例程序如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBase</span>    <span class="hljs-comment">// 基类(父类)</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// dynamic_cast在将父类cast到子类时，父类必须要有虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">// 一定要是 virtual</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CDerived</span> : <span class="hljs-keyword">public</span> CBase  <span class="hljs-comment">// 派生类(子类)</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CBase *p_CBase = <span class="hljs-keyword">new</span> CBase;  <span class="hljs-comment">// 基类对象指针</span><br>CDerived *p_CDerived = <span class="hljs-built_in">dynamic_cast</span>&lt;CDerived *&gt;(p_CBase);  <span class="hljs-comment">// 将基类对象指针类型转换为派生类对象指针</span><br><br>CBase i_CBase;    <span class="hljs-comment">// 创建基类对象</span><br>CBase &amp;r_CBase = i_CBase;    <span class="hljs-comment">// 基类对象的引用</span><br>CDerived &amp;r_CDerived = <span class="hljs-built_in">dynamic_cast</span>&lt;CDerived &amp;&gt;(r_CBase);  <span class="hljs-comment">// 将基类对象的引用转换派生类对象的引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="const-cast-常量转换"><a href="#const-cast-常量转换" class="headerlink" title="const_cast(常量转换)"></a>const_cast(常量转换)</h2><ol><li>使用场景</li></ol><p>常量指针（或引用）与非常量指针（或引用）之间的转换。</p><ol start="2"><li>使用特点</li></ol><ul><li><code>cosnt_cast</code> 是四种类型转换符中唯一可以对常量进行操作的转换符。</li><li>去除常量性是一个危险的动作，尽量避免使用。</li></ul><ol start="3"><li>示例程序如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> value = <span class="hljs-number">100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cpi = &amp;value; <span class="hljs-comment">// 定义一个常量指针</span><br><span class="hljs-comment">//*cpi = 200;   // 不能通过常量指针修改值</span><br><br><span class="hljs-comment">// 1. 将常量指针转换为非常量指针,然后可以修改常量指针指向变量的值</span><br><span class="hljs-type">int</span> *pi = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(cpi);<br>*pi = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">// 2. 将非常量指针转换为常量指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *cpi2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> *&gt;(pi); <span class="hljs-comment">// *cpi2 = 300;  //已经是常量指针</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> value1 = <span class="hljs-number">500</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c_value1 = value1; <span class="hljs-comment">// 定义一个常量引用</span><br><br><span class="hljs-comment">// 3. 将常量引用转换为非常量引用</span><br><span class="hljs-type">int</span> &amp;r_value1 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(c_value1);<br><br><span class="hljs-comment">// 4. 将非常量引用转换为常量引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c_value2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&gt;(r_value1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="reinterpret-cast-不相关类型的转换"><a href="#reinterpret-cast-不相关类型的转换" class="headerlink" title="reinterpret_cast(不相关类型的转换)"></a>reinterpret_cast(不相关类型的转换)</h2><p><code>reinterpret</code> 的英文含义有重新转换的含义，就相当于 C 语言中不相关类型的转换,强转。</p><ol><li>使用场景</li></ol><ul><li>用在任意指针（或引用）类型之间的转换。</li><li>能够将整型转换为指针，也可以把指针转换为整型或数组。</li></ul><ol start="2"><li>使用特点</li></ol><ul><li><code>reinterpret_cast</code> 是从底层对数据进行重新解释，依赖具体的平台，可移植性差。</li><li>不到万不得已，不用使用这个转换符，高危操作。</li></ul><ol start="3"><li>示例程序如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> value = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// 1. 用在任意指针（或引用）类型之间的转换</span><br><span class="hljs-type">double</span> *pd = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span> *&gt;(&amp;value);<br>cout &lt;&lt; <span class="hljs-string">&quot;*pd = &quot;</span> &lt;&lt; *pd &lt;&lt; endl;<br><br><span class="hljs-comment">// 2. reinterpret_cast能够将指针值转化为整形值</span><br><span class="hljs-type">int</span> *pv = &amp;value;<br><span class="hljs-type">int</span> pvaddr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pv);<br>cout &lt;&lt; <span class="hljs-string">&quot;pvaddr = &quot;</span> &lt;&lt; hex &lt;&lt; pvaddr &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;pv = &quot;</span> &lt;&lt; pv &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*pd = -9.25596e+61</span><br><span class="hljs-comment">pvaddr = 8ffe60</span><br><span class="hljs-comment">pv = 008FFE60</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>下面程序中，参数 pb 指向的是 B 类对象，pd1 的值不为0，而 pd2 的值为 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-type">int</span> m_iNum;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-type">char</span> *m_szName[<span class="hljs-number">100</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(B* pb)</span></span><br><span class="hljs-function"></span>&#123;<br>    D *pd1 = <span class="hljs-built_in">static_cast</span>&lt;D *&gt;(pb);<br>    D *pd2 = <span class="hljs-built_in">dynamic_cast</span>&lt;D *&gt;(pb);<br>    <br>cout &lt;&lt; pd1 &lt;&lt; endl; <span class="hljs-comment">//00CFF7C0</span><br>cout &lt;&lt; pd2 &lt;&lt; endl; <span class="hljs-comment">//00000000    </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>B pb; <span class="hljs-comment">//父类对象pb</span><br>cout &lt;&lt; <span class="hljs-string">&quot;&amp;pb: &quot;</span> &lt;&lt; &amp;pb &lt;&lt; endl; <span class="hljs-comment">//&amp;pb: 00CFF7C0    </span><br><span class="hljs-built_in">func</span>(&amp;pb);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&amp;pb: 00CFF7C0</span><br><span class="hljs-comment">00CFF7C0</span><br><span class="hljs-comment">00000000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++函数重载和参数的缺省值</title>
    <link href="/2024/01/15/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%80%BC/"/>
    <url>/2024/01/15/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%92%8C%E5%8F%82%E6%95%B0%E7%9A%84%E7%BC%BA%E7%9C%81%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/11309893.html">https://www.cnblogs.com/linuxAndMcu/p/11309893.html</a></p></blockquote><h1 id="C-函数重载和参数的缺省值"><a href="#C-函数重载和参数的缺省值" class="headerlink" title="C++函数重载和参数的缺省值"></a>C++函数重载和参数的缺省值</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="重载的起源"><a href="#重载的起源" class="headerlink" title="重载的起源"></a>重载的起源</h3><p>自然语言中，一个词可以有许多不同的含义，即该词被重载了。人们可以通过上下文来判断该词到底是哪种含义。“词的重载”可以使语言更加简练。例如“吃饭”的含义十分广泛，人们没有必要每次非得说清楚具体吃什么不可。别迂腐得象孔已己，说茴香豆的茴字有四种写法。</p><p><strong>在 C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，即函数重载。这样便于记忆，提高了函数的易用性，这是 C++语言采用重载机制的一个理由。</strong> 例如下例中的函数 <code>eatBeef</code>，<code>eatFish</code>，<code>eatChicken</code> 可以用同一个函数名 Eat 表示，用不同类型的参数加以区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 重载函数 Eat</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eatBeef</span><span class="hljs-params">(…)</span></span>; <span class="hljs-comment">// 可以改为 void eat(Beef …);</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eatFish</span><span class="hljs-params">(…)</span></span>; <span class="hljs-comment">// 可以改为 void eat(Fish …);</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eatChicken</span><span class="hljs-params">(…)</span></span>; <span class="hljs-comment">// 可以改为 void eat(Chicken …);</span><br></code></pre></td></tr></table></figure><p><strong>C++语言采用重载机制的另一个理由是：类的构造函数需要重载机制。</strong> 因为 C++规定构造函数与类同名，构造函数只能有一个名字。如果想用几种不同的方法创建对象该怎么办？别无选择，只能用重载机制来实现。所以类可以有多个同名的构造函数。</p><h3 id="重载是如何实现的？"><a href="#重载是如何实现的？" class="headerlink" title="重载是如何实现的？"></a>重载是如何实现的？</h3><p>几个同名的重载函数仍然是不同的函数，它们是如何区分的呢？</p><p>我们自然想到函数接口的两个要素：参数与返回值。<strong>如果同名函数的参数不同（包括类型、顺序不同），那么容易区别出它们是不同的函数。</strong></p><p>如果同名函数仅仅是返回值类型不同，有时可以区分，有时却不能。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>上述两个函数，第一个没有返回值，第二个的返回值是 int 类型。如果这样调用<br>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-built_in">function</span> ();<br></code></pre></td></tr></table></figure><p>则可以判断出 <code>function</code> 是第二个函数。问题是在 C++&#x2F;C 程序中，我们可以忽略函数的返回值。在这种情况下，编译器和程序员都不知道哪个 <code>function</code> 函数被调用。</p><p>所以只能靠参数而不能靠返回值类型的不同来区分重载函数。编译器根据参数为每个重载函数产生不同的内部标识符。例如编译器为上例中的三个 <code>eat</code> 函数产生像 <code>_eat_beef</code>、<code>_eat_fish</code>、<code>_eat_chicken</code> 之类的内部标识符（不同的编译器可能产生不同风格的内部标识符）。</p><p>如果 C++程序要调用已经被编译后的 C 函数，该怎么办？</p><p>假设某个 C 函数的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数被 <code>C</code> 编译器编译后在库中的名字为<code>_foo</code>，而 <code>C++</code>编译器则会产生像 <code>_foo_int_int</code> 之类的名字用来支持函数重载和类型安全连接。由于编译后的名字不同，<code>C++</code>程序不能直接调用 <code>C</code> 函数。<code>C++</code>提供了一个 <code>C</code> 连接交换指定符号 <code>extern “C”</code> 来解决这个问题。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> “C”<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br>… <span class="hljs-comment">// 其它函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> “C”<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> “myheader.h”</span><br>… <span class="hljs-comment">// 其它 C 头文件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就告诉 <code>C++</code> 编译译器，函数 <code>foo</code> 是个 <code>C</code> 连接，应该到库中找名字<code>_foo</code> 而不是找<code>_foo_int_int</code>。<code>C++</code>编译器开发商已经对 <code>C</code> 标准库的头文件作了 <code>extern “C”</code> 处理，所以我们可以用 <code>#include</code> 直接引用这些头文件。</p><p>注意并不是两个函数的名字相同就能构成重载。全局函数和类的成员函数同名不算重载，因为函数的作用域不同。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(…)</span></span>; <span class="hljs-comment">// 全局函数</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>…<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(…)</span></span>; <span class="hljs-comment">// 成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不论两个 <code>print</code> 函数的参数是否不同，如果类的某个成员函数要调用全局函数 <code>print</code>，为了与成员函数 <code>print</code> 区别，全局函数被调用时应加 <code>‘::’</code> 标志。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">::<span class="hljs-built_in">Print</span>(…); <span class="hljs-comment">// 表示 Print 是全局函数而非成员函数</span><br></code></pre></td></tr></table></figure><h3 id="当心隐式类型转换"><a href="#当心隐式类型转换" class="headerlink" title="当心隐式类型转换"></a>当心隐式类型转换</h3><p>下例中，第一个 <code>output</code> 函数的参数是 <code>int</code> 类型，第二个 <code>output</code> 函数的参数是 <code>float</code> 类型。<strong>由于数字本身没有类型，将 数字当作参数时将自动进行类型转换（称为隐式类型转换）。语句 <code>output(0.5)</code>将产生编译错误，因为编译器不知道该将 <code>0.5</code> 转换成 <code>int</code> 还是 <code>float</code> 类型的参数。隐式类型转换在很多地方可以简化程序的书写，但是也可能留下隐患。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">( <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; output int &quot;</span> &lt;&lt; x &lt;&lt; endl ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">( <span class="hljs-type">float</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; output float &quot;</span> &lt;&lt; x &lt;&lt; endl ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">float</span> y = <span class="hljs-number">1.0</span>;<br>    <br>    <span class="hljs-built_in">output</span>(x); <span class="hljs-comment">// output int 1</span><br>    <span class="hljs-built_in">output</span>(y); <span class="hljs-comment">// output float 1</span><br>    <span class="hljs-built_in">output</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// output int 1</span><br>    <span class="hljs-comment">// output(0.5); // error! ambiguous call, 因为自动类型转换</span><br>    <span class="hljs-built_in">output</span>(<span class="hljs-built_in">int</span>(<span class="hljs-number">0.5</span>)); <span class="hljs-comment">// output int 0</span><br>    <span class="hljs-built_in">output</span>(<span class="hljs-built_in">float</span>(<span class="hljs-number">0.5</span>)); <span class="hljs-comment">// output float 0.5</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参数的缺省值"><a href="#参数的缺省值" class="headerlink" title="参数的缺省值"></a>参数的缺省值</h2><p>有一些参数的值在每次函数调用时都相同，书写这样的语句会使人厌烦。<code>C++</code> 语言采用参数的缺省值使书写变得简洁（在编译时，缺省值由编译器自动插入）。</p><p>参数缺省值的使用规则：</p><p><strong>【规则 2-1】</strong> 参数缺省值只能出现在函数的声明中，而不能出现在定义体中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 正确，缺省值出现在函数的声明中</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>)</span> <span class="hljs-comment">// 错误，缺省值出现在函数的定义体中</span></span><br><span class="hljs-function"></span>&#123;<br>…<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么会这样？我想是有两个原因：一是函数的实现（定义）本来就与参数是否有缺省值无关，所以没有必要让缺省值出现在函数的定义体中。二是参数的缺省值可能会改动，显然修改函数的声明比修改函数的定义要方便。</p><p><strong>【规则 2-2】</strong> 如果函数有多个参数，参数只能从后向前挨个儿缺省，否则将导致函数调用语句怪模怪样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> z=<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z=<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>要注意，使用参数的缺省值并没有赋予函数新的功能，仅仅是使书写变得简洁一些。它可能会提高函数的易用性，但是也可能会降低函数的可理解性。所以我们只能适当地使用参数的缺省值，要防止使用不当产生负面效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">( <span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">( <span class="hljs-type">int</span> x, <span class="hljs-type">float</span> y=<span class="hljs-number">0.0</span>)</span></span>; <span class="hljs-comment">// 参数缺省值只能出现在函数的声明中</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br><span class="hljs-type">float</span> y=<span class="hljs-number">0.5</span>;<br><span class="hljs-comment">// output(x); // error! ambiguous call</span><br><span class="hljs-built_in">output</span>(x,y); <span class="hljs-comment">// output int 1 and float 0.5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">( <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; output int &quot;</span> &lt;&lt; x &lt;&lt; endl ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">( <span class="hljs-type">int</span> x, <span class="hljs-type">float</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; output int &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; and float &quot;</span> &lt;&lt; y &lt;&lt; endl ;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，不合理地使用参数的缺省值将导致重载函数 <code>output</code> 产生二义性。</p><p><strong>参考：</strong></p><p>《高质量C++C 编程指南 林锐》的第8章 C++函数的高级特性</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>function与bind实现函数回调功能</title>
    <link href="/2024/01/13/function%E4%B8%8Ebind%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%8A%9F%E8%83%BD/"/>
    <url>/2024/01/13/function%E4%B8%8Ebind%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576162.html">https://www.cnblogs.com/linuxAndMcu/p/14576162.html</a></p></blockquote><h1 id="function与bind实现函数回调功能"><a href="#function与bind实现函数回调功能" class="headerlink" title="function与bind实现函数回调功能"></a>function与bind实现函数回调功能</h1><h2 id="std-function与std-bind双剑合璧"><a href="#std-function与std-bind双剑合璧" class="headerlink" title="std::function与std::bind双剑合璧"></a>std::function与std::bind双剑合璧</h2><p>因为类成员函数都有一个默认的参数，<code>this</code>，作为第一个参数，这就导致了类成员函数不能直接赋值给<code>std::function</code>，这时候我们就需要<code>std::bind</code>了，简言之，<code>std::bind</code>的作用就是转换函数签名，将缺少的参数补上，将多了的参数去掉，甚至还可以交换原来函数参数的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 类成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">classMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 类成员函数（使用std::bind绑定类成员函数）</span><br>TestClass testObj;<br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; functional = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-function与std-bind实现函数回调功能"><a href="#std-function与std-bind实现函数回调功能" class="headerlink" title="std::function与std::bind实现函数回调功能"></a>std::function与std::bind实现函数回调功能</h2><p>在 <code>C++11</code> 之前，回调函数一般是通过函数指针实现，函数指针的用法非常简单，但是它只能指向全局或静态函数，这有点太不灵活了，而且我们都知道在 <code>C/C++</code> 中，全局的东西都很可怕，稍有不慎就会被篡改或随便调用。</p><p>但幸好，在 <code>C++11</code> 之后，我们多了一种选择：<code>std::function</code>。<code>std::function</code>可以说是函数指针的超集，它除了可以指向全局和静态函数，还可以指向仿函数，Lambda 表达式，类成员函数，甚至函数签名不一致的函数，可以说几乎所有可以调用的对象都可以当做<code>std::function</code>，当然对于后两个需要使用<code>std::bind</code>进行配合。</p><p>当然，任何东西都会有优缺点，<code>std::function</code>填补了函数指针的灵活性，但会对调用性能有一定损耗，经测试发现，在调用次数达 10 亿次时，函数指针比直接调用要慢 2 秒左右，而<code>std::function</code>要比函数指针慢 2 秒左右，这么少的损耗如果是对于调用次数并不高的函数，替换成<code>std::function</code>绝对是划得来的。</p><p>下面我们通过一个例子说明<code>std::function</code>与<code>std::bind</code>是怎么实现函数回调功能的。</p><p>线程类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> tTask = std::function&lt;<span class="hljs-built_in">void</span>(std::string)&gt;;<br><br><span class="hljs-comment">// 线程类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadObject</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ThreadObject</span>() &#123;&#125;<br>~<span class="hljs-built_in">ThreadObject</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">settask</span><span class="hljs-params">(tTask task)</span></span><br><span class="hljs-function"></span>&#123;<br>m_task = task;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 回调执行任务函数</span><br><span class="hljs-built_in">m_task</span>(<span class="hljs-string">&quot;http://172.0.0.1/test.zip&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>tTask m_task; <span class="hljs-comment">// std::function类型，调用者，调用回调函数</span><br>&#125;;<br><br><span class="hljs-comment">// 下载任务函数，也是回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">downTask</span><span class="hljs-params">(std::string str)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;download &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ThreadObject.hpp&quot;</span></span><br> <br><span class="hljs-comment">// 下载任务函数，也是回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">downTask</span><span class="hljs-params">(std::string str)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;download &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ThreadObject Threadobj;<br>Threadobj.<span class="hljs-built_in">settask</span>(std::<span class="hljs-built_in">bind</span>(&amp;downTask, std::placeholders::_1)); <span class="hljs-comment">// 设置任务函数</span><br>Threadobj.<span class="hljs-built_in">run</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展：std-bind与std-function模拟实现Qt信号槽"><a href="#扩展：std-bind与std-function模拟实现Qt信号槽" class="headerlink" title="扩展：std::bind与std::function模拟实现Qt信号槽"></a>扩展：std::bind与std::function模拟实现Qt信号槽</h2><p>Qt 信号槽实现信号的发送和接收，类似观察者。简单说明：</p><ul><li><code>sender</code>：发出信号的对象</li><li><code>signal</code>：发送对象发出的信号</li><li><code>receiver</code>：接收信号的对象</li><li><code>slot</code>：接收对象在接收到信号之后所需要调用的函数（槽函数）</li><li><code>emit</code>：发送信号<br>这里准备用<code>std::function</code>与<code>std::bind</code>模拟实现 Qt 信号槽。</li></ul><p>下面实现第一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 信号对象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalObject</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; slotFun)</span></span><br><span class="hljs-function"></span>&#123;<br>m_callFun = slotFun;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> signalVal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">m_callFun</span>(signalVal);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt;  m_callFun; <span class="hljs-comment">// 回调函数，存储槽函数</span><br>&#125;;<br><br><span class="hljs-comment">// 槽对象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SlotObject</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SlotObject</span>() &#123;&#125;<br>    <br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slotMember</span><span class="hljs-params">(<span class="hljs-type">int</span> signalVal)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;signal:&quot;</span> &lt;&lt; signalVal &lt;&lt; <span class="hljs-string">&quot; recv:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>SignalObject signalObject; <span class="hljs-comment">// 信号对象</span><br>SlotObject slotObject; <span class="hljs-comment">// 槽对象</span><br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;slotObject:&quot;</span> &lt;&lt; &amp;slotObject &lt;&lt; std::endl;<br><span class="hljs-comment">// 连接信号槽（此时m_callFun存储着slotMember函数对象）</span><br>signalObject.<span class="hljs-built_in">connect</span>(std::<span class="hljs-built_in">bind</span>(&amp;SlotObject::slotMember, slotObject, std::placeholders::_1));<br><span class="hljs-comment">// 发射信号</span><br>signalObject.<span class="hljs-built_in">emitSignal</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">slotObject:<span class="hljs-number">00</span>D3FDEF<br>signal:<span class="hljs-number">1</span> recv:<span class="hljs-number">00</span>D3FE01<br></code></pre></td></tr></table></figure><p>可以发现成功调用了回调函数，并正确接收到了信号，我们的成员函数可以通过回调实现了调用。但是接收者的地址并不是我们定义的 slotobject，即 connect 的是别的对象，具体可以参考<a href="https://blog.csdn.net/weixin_43333380/article/details/82935291">开篇链接介绍</a>知，connect 过程发生了拷贝构造。</p><h3 id="避免拷贝构造"><a href="#避免拷贝构造" class="headerlink" title="避免拷贝构造"></a>避免拷贝构造</h3><p>修改我们的信号类，可以避免拷贝构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 信号对象类2：避免了拷贝构造</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalObject2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(SlotObject* recver, std::function&lt;<span class="hljs-type">void</span>(SlotObject*, <span class="hljs-type">int</span>)&gt; slotFun)</span></span><br><span class="hljs-function"></span>&#123;<br>m_recver = recver; <span class="hljs-comment">// 保存连接的槽对象</span><br>m_callFun = slotFun;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> signal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">m_callFun</span>(m_recver, signal);<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>SlotObject* m_recver;<br>std::function&lt;<span class="hljs-type">void</span>(SlotObject*, <span class="hljs-type">int</span>)&gt;  m_callFun;<br>&#125;;<br></code></pre></td></tr></table></figure><p>即我们在 connect 时把 recver 保存起来。</p><p>客户端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>SignalObject2 signalObject2;<br>SlotObject   slotObject;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;slotObject:&quot;</span> &lt;&lt; &amp;slotObject &lt;&lt; std::endl;<br><span class="hljs-comment">// 连接信号槽</span><br>std::function&lt;<span class="hljs-type">void</span>(SlotObject*, <span class="hljs-type">int</span>)&gt; slot = &amp;SlotObject::slotMember;<br>signalObject2.<span class="hljs-built_in">connect</span>(&amp;slotObject, slot);<br><span class="hljs-comment">// 发射信号</span><br>signalObject2.<span class="hljs-built_in">emitSignal</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;:<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">slotObject:<span class="hljs-number">008F</span>FBD3<br>signal:<span class="hljs-number">2</span> recv:<span class="hljs-number">008F</span>FBD3<br></code></pre></td></tr></table></figure><h3 id="sender类实现"><a href="#sender类实现" class="headerlink" title="sender类实现"></a>sender类实现</h3><p>当一个槽 <code>slot</code> 和多个信号 <code>signal</code> 连接者，我们并不知道是谁调用的，<code>Qt</code> 中我们知道可以通过 <code>sender()</code> 返回一个 <code>QObject*</code> 来判断，这里模仿实现 <code>sender</code> 方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Object类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Object* <span class="hljs-title">self</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>std::function&lt;Object* (<span class="hljs-type">void</span>)&gt;  m_sender;<br>&#125;;<br><br><span class="hljs-comment">// 槽对象类3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SlotObject3</span> :<span class="hljs-keyword">public</span> Object<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SlotObject3</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slotMember</span><span class="hljs-params">(<span class="hljs-type">int</span> signal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (m_sender) &#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;sender:&quot;</span> &lt;&lt; <span class="hljs-built_in">m_sender</span>() &lt;&lt; std::endl;<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;signal:&quot;</span> &lt;&lt; signal &lt;&lt; <span class="hljs-string">&quot; recv:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 信号对象类3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SignalObject3</span> :<span class="hljs-keyword">public</span> Object<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(SlotObject3* recver, std::function&lt;<span class="hljs-type">void</span>(SlotObject3*, <span class="hljs-type">int</span>)&gt; slot)</span></span><br><span class="hljs-function"></span>&#123;<br>m_recver = recver;<br>m_callFun = slot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> signal)</span></span><br><span class="hljs-function"></span>&#123;<br>m_recver-&gt;m_sender = std::<span class="hljs-built_in">bind</span>(&amp;SignalObject3::self, <span class="hljs-keyword">this</span>);<br><span class="hljs-built_in">m_callFun</span>(m_recver, signal);<br>m_recver-&gt;m_sender = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>SlotObject3* m_recver;<br>std::function&lt;<span class="hljs-type">void</span>(SlotObject3*, <span class="hljs-type">int</span>)&gt;  m_callFun;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>即定义一个基类 <code>Object</code> 和一个回调变量 <code>sender</code>，在每次发送时绑定上发送者即可。</p><p>客户端：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>SignalObject3 signalObject3;<br>SlotObject3   slotObject3;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;signalObject3:&quot;</span> &lt;&lt; &amp;signalObject3 &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;slotObject3:&quot;</span> &lt;&lt; &amp;slotObject3 &lt;&lt; std::endl;<br><span class="hljs-comment">// 连接信号槽</span><br>std::function&lt;<span class="hljs-type">void</span>(SlotObject3*, <span class="hljs-type">int</span>)&gt; slot3 = &amp;SlotObject3::slotMember;<br>signalObject3.<span class="hljs-built_in">connect</span>(&amp;slotObject3, slot3);<br><span class="hljs-comment">// 发射信号</span><br>signalObject3.<span class="hljs-built_in">emitSignal</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">signalObject3:<span class="hljs-number">00</span>DDFC40<br>slotObject3:<span class="hljs-number">00</span>DDFC10<br>sender:<span class="hljs-number">00</span>DDFC40<br>signal:<span class="hljs-number">3</span> recv:<span class="hljs-number">00</span>DDFC10<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回调入门</title>
    <link href="/2024/01/08/%E5%9B%9E%E8%B0%83%E5%85%A5%E9%97%A8/"/>
    <url>/2024/01/08/%E5%9B%9E%E8%B0%83%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576158.html">https://www.cnblogs.com/linuxAndMcu/p/14576158.html</a></p></blockquote><h1 id="回调入门"><a href="#回调入门" class="headerlink" title="回调入门"></a>回调入门</h1><h2 id="函数指针概述"><a href="#函数指针概述" class="headerlink" title="函数指针概述"></a>函数指针概述</h2><p>指针是一个变量，是用来指向内存地址的。一个程序运行时，所有和运行相关的物件都是需要加载到内存中，这就决定了程序运行时的任何物件都可以用指针来指向它。<strong>函数是存放在内存代码区域内的，它们同样有地址，因此同样可以用指针来存取函数，把这种指向函数入口地址的指针称为函数指针。</strong></p><p>下面是个使用函数指针的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 也可以用宏定义的方式来声明函数指针</span><br><span class="hljs-comment">// typedef int (*fp)(int, int);</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 定义一个函数指针fp，初始化指向testFun函数</span><br><span class="hljs-built_in">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = testFun;<br><span class="hljs-comment">// 通过函数指针fp，调用testFun函数</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">fp</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>std::cout &lt;&lt; sum &lt;&lt; std::endl; <span class="hljs-comment">// 输出：3</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上知道：函数指针与函数的声明之间唯一区别就是，用指针名<code>（*fp）</code>代替了函数名 <code>testFun</code>，这样这声明了一个函数指针，然后进行赋值<code>fp=testFun</code>就可以进行函数指针的调用了。下面可以讨论需要用到函数指针的回调函数了。</p><h2 id="回调函数概述"><a href="#回调函数概述" class="headerlink" title="回调函数概述"></a>回调函数概述</h2><p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><p>回调函数的机制如下：</p><ul><li>定义一个回调函数；</li><li>提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；</li><li>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</li></ul><h2 id="回调函数的意义"><a href="#回调函数的意义" class="headerlink" title="回调函数的意义"></a>回调函数的意义</h2><p>因为可以把调用者与被调用者分开，所以调用者不关心谁是被调用者。它只需知道存在一个具有特定原型和限制条件的被调用函数。简而言之，回调函数就是允许用户把需要调用的函数的指针作为参数传递给一个函数，以便该函数在处理相似事件的时候可以灵活的使用不同的方法。下面看几个应用：</p><ul><li>回调可用于通知机制。比如要写一个多线程下载器，需要显示下载进度，在另外的下载线程类中下载好了文件时，此时不方便也不允许直接调用进度条界面的刷新进度值函数，这时候就需要将刷新进度值函数设置为回调函数了，作为下载线程中调用者函数的参数，执行调用者函数就相当于执行回调函数，就可以刷新界面的进度值了。</li><li>另一个使用回调机制的 <code>API</code> 函数是 <code>EnumWindow(）</code>，它枚举屏幕上所有的顶层窗口，每个窗口都可以通过它调用另一个程序提供的函数，并传递窗口的处理程序。例如：如果被调用者返回一个值，就继续进行迭代；否则，退出。<code>EnumWindow()</code> 并不关心被调用者在何处，也不关心被调用者用它传递的处理程序做了什么，它只关心返回值，因为基于返回值，它将继续执行或退出。</li><li>还有图形界面客户端常用 <code>事件循环 (event loop)</code> 有条不紊的处理用户输入&#x2F;计时器&#x2F;系统处理&#x2F;跨进程通信 等事件，一般采用回调响应事件。<br>注意：不管怎么说，回调函数是继承自<code>C</code>语言的。在 <code>C++ 中</code>，应只在与<code>C</code>代码建立接口或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在 <code>C++</code> 中应使用虚拟方法或仿函数（functor），而不是回调函数。</li></ul><h2 id="用函数指针实现回调函数"><a href="#用函数指针实现回调函数" class="headerlink" title="用函数指针实现回调函数"></a>用函数指针实现回调函数</h2><p>不带参回调函数的示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义不带参回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callbackFun</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This is callbackFun&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义参数为回调函数的调用者（一般在其它系统或子线程中）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callbackExec</span><span class="hljs-params">(<span class="hljs-type">void</span> (*fp)())</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fp</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 当特定的事件或条件发生的时候，调用者调用回调函数callbackFun</span><br><span class="hljs-built_in">callbackExec</span>(callbackFun); <span class="hljs-comment">// 输出：&quot;This is callbackFun&quot;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>带参回调函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义带参回调函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">callbackFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// 定义参数为回调函数的&quot;调用函数&quot;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">callbackExec</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fp</span>(a, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 运行时执行&quot;调用函数&quot;，调用回调函数callbackFun</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">callbackExec</span>(callbackFun, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>std::cout &lt;&lt; sum &lt;&lt; std::endl; <span class="hljs-comment">// 输出：3</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda</title>
    <link href="/2024/01/04/Lambda/"/>
    <url>/2024/01/04/Lambda/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14575998.html">https://www.cnblogs.com/linuxAndMcu/p/14575998.html</a></p></blockquote><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><h2 id="C-11为什么要引入Lambda表达式？"><a href="#C-11为什么要引入Lambda表达式？" class="headerlink" title="C++11为什么要引入Lambda表达式？"></a>C++11为什么要引入Lambda表达式？</h2><p>编写程序时，往往会大量用到函数，为此要编写很多类。有的类只用来定义了一个函数成员，而且这个函数也只使用了一次，编写这样的类就有点浪费。而且，定义类的地方和使用成员函数的地方可能相隔较远，查看其 <code>operator()</code> 成员函数也比较麻烦。</p><p>对于只使用一次的类，能否直接在使用它的地方定义呢？所以 <code>C++11</code> 引入了 <code>Lambda</code> 表达式，这样就可以减少程序中类的数量，使得程序更加优雅。而且可以避免想函数名了，其实有时候取名字真的是件麻烦事。</p><p>现在就可以看出 <code>Lambda</code> 表达式的使用场景了：</p><p>在你的整个项目编程中，你独立出来一个函数，但这个函数实现相对简单并且可能在整个项目只使用了一次(即不存在复用的情况)，那么这个时候就可以考虑使用下 <code>Lambda</code> 表达式了，这样可以让代码更加紧凑，更加容易维护。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Lambda</code> 表达式，顾名思义，它是一个表达式，和常规函数表达式不同的是它是“匿名”的，也就是没有函数名的表达式（简称匿名表达式）。利用 <code>Lambda</code> 表达式，可以方便的定义和创建匿名函数。</p><p>对于 <code>C++</code> 这门语言来说来说，“Lambda 表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了 Lambda 表达式的功能，如 C#，Python，JAVA 等。</p><p><code>Lambda</code> 表达式基于数学中的λ演算得名，直接对应于其中的 <code>lambda</code> 抽象(<code>lambda abstraction</code>)。<code>Lambda</code>表达式可以表示闭包。（注意和数学传统意义上的不同）</p><p>闭包就是能够读取其他函数内部变量的函数。例如在 <code>javascript</code> 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。这句话里面重点，闭包是一个函数内部的函数，可以读取它所关联函数的局部变量。</p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p><code>Lambda</code> 表达式的函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (params list) <span class="hljs-keyword">mutable</span> exception-&gt; <span class="hljs-keyword">return</span> type &#123; function body &#125;<br></code></pre></td></tr></table></figure><p>各项具体含义如下：</p><ul><li><p>capture list：捕获外部变量列表</p></li><li><p>params list：形参列表</p></li><li><p>mutable指示符：用来说用是否可以修改捕获的变量</p></li><li><p>exception：异常设定</p></li><li><p>return type：返回类型</p></li><li><p>function body：函数体<br>此外，我们还可以省略其中的某些成分来声明“不完整”的 Lambda 表达式，常见的有以下几种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 格式1</span><br>[capture list] (params list) -&gt; <span class="hljs-keyword">return</span> type &#123;function body&#125;<br><span class="hljs-comment">// 格式2</span><br>[capture list] (params list) &#123;function body&#125;<br><span class="hljs-comment">// 格式3</span><br>[capture list] &#123;function body&#125;<br><br></code></pre></td></tr></table></figure><p>其中：</p></li><li><p>格式 1 声明了 <code>const</code> 类型的表达式，这种类型的表达式不能修改捕获列表中的值。</p></li><li><p>格式 2 省略了返回值类型，但编译器可以根据以下规则推断出 Lambda 表达式的返回类型：</p><ol><li>如果 <code>function body</code> 中存在 <code>return</code> 语句，则该 <code>Lambda</code> 表达式的返回类型由<code>return</code>语句的返回类型确定；</li><li>如果 <code>function body</code> 中没有 <code>return</code> 语句，则返回值为 <code>void</code> 类型。</li></ol></li><li><p>格式 3 中省略了参数列表，类似普通函数中的无参函数。</p></li></ul><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span>  a &lt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; myvec&#123; <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span> &#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lbvec</span><span class="hljs-params">(myvec)</span></span>;<br><br><span class="hljs-comment">// 旧式做法</span><br><span class="hljs-built_in">sort</span>(myvec.<span class="hljs-built_in">begin</span>(), myvec.<span class="hljs-built_in">end</span>(), compare);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;predicate function:&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : myvec)<br>std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>std::cout &lt;&lt; std::endl;<br><br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-built_in">sort</span>(lbvec.<span class="hljs-built_in">begin</span>(), lbvec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a &lt; b; &#125;);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;lambda expression:&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : lbvec)<br>std::cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>C++11</code> 之前，我们使用 <code>STL</code> 的 <code>sort</code> 函数，需要提供一个谓词函数。如果使用 <code>C++11</code> 的 <code>Lambda</code> 表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p><h2 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h2><p><code>Lambda</code> 表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该 <code>Lambda</code> 表达式使用）。那么，在哪里指定这些外部变量呢？<code>Lambda</code> 表达式通过在最前面的方括号 <code>[]</code> 来明确指明其内部可以访问的外部变量，这一过程也称过 <code>Lambda</code> 表达式“捕获”了外部变量。</p><p>我们通过一个例子来直观地说明一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">auto</span> f = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;<br><span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：123</span><br><br><span class="hljs-comment">// 或通过“函数体”后面的‘()’传入参数</span><br>[](<span class="hljs-type">int</span> a) &#123;std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;(<span class="hljs-number">123</span>); <span class="hljs-comment">// 输出：123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子先声明了一个整型变量 <code>a</code>，然后再创建 <code>Lambda</code> 表达式，该表达式“捕获”了 <code>a</code> 变量，这样在 <code>Lambda</code>表达式函数体中就可以获得该变量的值。</p><p><strong>类似参数传递方式（值传递、引入传递、指针传递），在 Lambda 表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获</strong>。</p><h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">auto</span> f = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;; <br>    a = <span class="hljs-number">321</span>;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在 <code>Lambda</code> 表达式创建时通过值拷贝的方式传入，因此随后在外部对该变量的修改不会影响 <code>Lambda</code>表达式中的值，所以 <code>a</code> 还是 <code>123</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">auto</span> f = [a] &#123; a = <span class="hljs-number">321</span>; &#125;; <span class="hljs-comment">// 报错：error C3491: “a”: 无法在非可变 lambda 中修改通过复制捕获</span><br><span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，如果以传值方式捕获外部变量，则在 <code>Lambda</code> 表达式函数体中不能修改该外部变量的值，否则会引发编译错误。</p><h2 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h2><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符 <code>&amp;</code>。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; <br>    a = <span class="hljs-number">321</span>;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：321</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象，故输出的为 <code>321</code>。</p><h2 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h2><p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出 <code>Lambda</code> 表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是 <code>[=]</code> 和 <code>[&amp;]</code>。<code>[=]</code> 表示以值捕获的方式捕获外部变量，<code>[&amp;]</code> 表示以引用捕获的方式捕获外部变量。</p><p>隐式值捕获示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="hljs-comment">// 值捕获</span><br>    a = <span class="hljs-number">321</span>;    <br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>隐式引用捕获示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="hljs-comment">// 引用捕获</span><br>    a = <span class="hljs-number">321</span>;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：321</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h2><p>上面的例子，要么是值捕获，要么是引用捕获，<code>Lambda</code> 表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p><p>到这里，我们来总结一下，<code>Lambda</code> 表达式捕获外部变量主要有以下形式：</p><ul><li><code>[]</code> 不捕获任何外部变量</li><li><code>[变量名, …]</code> 默认以值的形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用 <code>&amp;</code> 说明符）</li><li><code>[=]</code> 值捕获，捕获所有外部变量，在函数内有个副本使用</li><li><code>[&amp;]</code> 引用捕获，捕获所有外部变量，在函数体内当作引用使用</li><li><code>[=, &amp;x]</code> 值捕获所有外部变量，只按引用捕获 <code>x</code> 变量</li><li><code>[&amp;, =x]</code> 引用捕获所有外部变量，只按值捕获 <code>x</code> 变量</li><li><code>[this]</code> 捕获当前类中的 <code>this</code> 指针。如果已经使用了 <code>&amp;</code> 或者 <code>=</code> 就默认添加此选项。</li></ul><h2 id="修改捕获变量"><a href="#修改捕获变量" class="headerlink" title="修改捕获变量"></a>修改捕获变量</h2><p>前面我们提到过，在 <code>Lambda</code> 表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用<code>mutable</code>关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">auto</span> f = [a]()<span class="hljs-keyword">mutable</span> &#123; cout &lt;&lt; ++a; &#125;; <span class="hljs-comment">// 不会报错</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 输出：123</span><br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 输出：124</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 输出：123</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但注意，修改的a仍然只是传入的副本，无法对外部的a进行修改</strong></p><h2 id="Lambda表达式的参数"><a href="#Lambda表达式的参数" class="headerlink" title="Lambda表达式的参数"></a>Lambda表达式的参数</h2><p><code>Lambda</code> 表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在 <code>Lambda</code> 表达式中传递参数还有一些限制，主要有以下几点：</p><ul><li>参数列表中不能有默认参数</li><li>不支持可变参数</li><li>所有参数必须有参数名</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bind</title>
    <link href="/2024/01/04/bind/"/>
    <url>/2024/01/04/bind/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14575979.html">https://www.cnblogs.com/linuxAndMcu/p/14575979.html</a></p></blockquote><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><h2 id="C-11为什么要引入std-bind？"><a href="#C-11为什么要引入std-bind？" class="headerlink" title="C++11为什么要引入std::bind？"></a>C++11为什么要引入std::bind？</h2><p>C++11 引入了<code>std::bind</code>，顾名思义，是用来绑定函数调用的某些参数的。<code>std::bind</code>能改造现有函数，生成新的函数。举例说明，现在有这么个函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>我现在需求，我要一个有 2 个 <code>int</code> 类型参数的函数，并且第2个参数默认为 <code>2</code>。你可千万不要屁颠屁颠的在去写一个<code>f(int i, int i = 2)</code>，这里<code>std::bind</code>的作用体现出来了，看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">bind</span>(&amp;f, std::placeholders::_1, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>好了，<code>std::bind</code>之后的返回值，那就可以拜托给我们的<code>std::funtion</code>同学了，我们定义个函数类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; fun = std::<span class="hljs-built_in">bind</span>(&amp;f, std::placeholders::_1, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>把<code>std::bind</code>的返回值给 <code>fun</code>，于是我们就生成了一个 <code>b</code> 强制为 <code>2</code>，只有 <code>1</code> 个<code>int a</code>参数的 <code>fun</code> 新函数。</p><p>最后要说一句，<code>std::bind</code>返回后的函数和原函数是 <code>2</code> 个完全不同的函数，这个你可以通过打印他们的内存地址看出来，这个就交给各位看官自己去实现了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>std::bind</code>函数定义在头文件<code>&lt;functional&gt;</code>中，是一个函数模板，它就像一个函数适配器，接受一个可调用对象<code>（callable object）</code>，生成一个新的可调用对象来“适应”原对象的参数列表。</p><p>使用<code>std::bind</code>可以将可调用对象和参数一起绑定，绑定后的结果使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候，所以经常用来实现回调函数。</p><p><code>std::bind</code>通常有两大作用：</p><ul><li>将可调用对象与参数一起绑定为另一个<code>std::function</code>供调用</li><li>将<code>n</code> 元可调用对象转成 <code>m(m &lt; n)</code> 元可调用对象，绑定一部分参数，这里需要使用<code>std::placeholders</code></li></ul><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p><code>std::bind</code>函数有两种函数原型，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-comment">/* unspecified */</span> <span class="hljs-built_in">bind</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ret</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-comment">/* unspecified */</span> <span class="hljs-built_in">bind</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><h3 id="函数模板说明"><a href="#函数模板说明" class="headerlink" title="函数模板说明"></a>函数模板说明</h3><ul><li>基于参数<code>fn</code>返回一个函数对象，并且以<code>args</code>参数绑定为函数对象的参数。</li><li>每个参数要么绑定一个参数值，要么绑定为一个<code>std::placeholders</code>（占位符，如 <code>_1</code>,<code> _2</code>, <code>...</code>, <code>_n</code>）。</li><li>如果参数绑定成一个值，那么返回的函数对象将总使用绑定的参数值做为调用参数，即调用传入参数将不起作用；如果参数绑定为<code>std::placeholders</code>，那么返回的函数对象在被调用时需要传入实时参数，参数填充的位置即由<code>placeholder</code>指定的序号。</li></ul><h3 id="函数模板参数说明"><a href="#函数模板参数说明" class="headerlink" title="函数模板参数说明"></a>函数模板参数说明</h3><ul><li><code>fn</code>：可调用的函数对象，比如函数对象、函数指针、函数引用、成员函数或者数据成员函数。</li><li><code>args</code>：需要绑定的函数的参数列表，使用命名空间占位符<code>std::placeholders::_1</code>，<code>std::placeholders::_2</code>标志参数，其中<code>std::placeholders::_1</code>标志为参数列表中的第一个参数，<code>std::placeholders::_2</code>标志参数列表中的第二个参数，<code>std::placeholders::_3</code>标志参数列表中的第三个参数，以此类推。</li></ul><h3 id="函数模板返回值说明"><a href="#函数模板返回值说明" class="headerlink" title="函数模板返回值说明"></a>函数模板返回值说明</h3><p>返回一个函数对象，该函数在调用时使用参数列表<code>args</code>来调用<code>fn</code>。如果<code>fn</code>是指向类的成员函数，则返回函数第一个参数应该是该类的成员、或者成员对象的引用、或者是成员对象的指针。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-keyword">auto</span> lamdaExps = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 1.类成员函数</span><br><span class="hljs-comment">// 2.类静态成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">classMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">staticMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 绑定普通函数(使用占位符先占位，然后执行时再传参)</span><br><span class="hljs-keyword">auto</span> bindFun = std::<span class="hljs-built_in">bind</span>(&amp;testFun, std::placeholders::_1, std::placeholders::_2);<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">bindFun</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数_1：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><span class="hljs-comment">// 绑定普通函数(也可以只使用一个占位符来占位，指定一个参数)</span><br><span class="hljs-keyword">auto</span> bindFun2 = std::<span class="hljs-built_in">bind</span>(&amp;testFun, std::placeholders::_1, <span class="hljs-number">8</span>);<br>ret = <span class="hljs-built_in">bindFun2</span>(<span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数_2：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 绑定Lambda表达式</span><br><span class="hljs-keyword">auto</span> bindFun3 = std::<span class="hljs-built_in">bind</span>(lamdaExps, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Lambda表达式：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 绑定仿函数</span><br>Functor testFunctor;<br><span class="hljs-keyword">auto</span> bindFun4 = std::<span class="hljs-built_in">bind</span>(testFunctor, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;仿函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 绑定类成员函数</span><br>TestClass testObj;<br><span class="hljs-keyword">auto</span> bindFun5 = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun5</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><span class="hljs-comment">// 绑定类静态成员函数</span><br><span class="hljs-keyword">auto</span> bindFun6 = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::staticMemberFun, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun6</span>(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类静态成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">普通函数_1：<span class="hljs-number">15</span><br>普通函数_2：<span class="hljs-number">18</span><br>Lambda表达式：<span class="hljs-number">30</span><br>仿函数：<span class="hljs-number">40</span><br>类成员函数：<span class="hljs-number">50</span><br>类静态成员函数：<span class="hljs-number">60</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>function</title>
    <link href="/2024/01/03/function/"/>
    <url>/2024/01/03/function/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载:<a href="https://www.cnblogs.com/linuxAndMcu/p/14575971.html">https://www.cnblogs.com/linuxAndMcu/p/14575971.html</a></p></blockquote><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="C-11为什么要引入std-function？"><a href="#C-11为什么要引入std-function？" class="headerlink" title="C++11为什么要引入std::function？"></a>C++11为什么要引入std::function？</h2><p>在 C++03 的时代，是使用函数指针来把一个函数作为参数传递，这样我们就可以实现回调函数的机制。程序设计，特别是程序库设计时，经常需要涉及到回调，如果针对每种不同的可调用对象单独进行声明类型，代码将会非常散乱，也不灵活。</p><p>所以 C++11 就引入了<code>std::function</code>类模板，这是一种通用、多态的函数封装，在头文件<code>&lt;functional&gt;</code>定义。<code>std::function</code>的实例可以对任何可以调用的目标对象进行存储、复制和调用操作。而函数指针只能指向一种类型的函数，并且函数指针也是类型不安全的。</p><p>可调用对象<code>（callable object）</code>包括：</p><ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>bind 创建的对象</li><li>重载了函数调用运算符的类（仿函数）</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对<code>std::function</code>最简单的理解就是：<code>std::function</code>实现了函数的存储，即先将可调用实体保存起来，在需要的时候再调用。</p><p>关于可调用对象转换为<code>std::function</code>对象需要遵守以下两条原则：</p><ul><li>转换后的<code>std::function</code>对象的参数能转换为可调用对象的参数；</li><li>可调用对象的返回值能转换为<code>std::function</code>对象的返回值。<br><code>std::function</code>可以绑定全局函数，静态函数，但是绑定类的成员函数时，必须要借助<code>std::bind</code>的帮忙。</li></ul><p>使用者需要注意，它不能被用来检查相等或者不相等，但是可以与 <code>NULL</code> 或者 <code>nullptr</code> 进行比较。</p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span>... Args &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">function</span>&lt;<span class="hljs-built_in">R</span>(Args...)&gt;<br></code></pre></td></tr></table></figure><ul><li><code>R</code> 是返回值类型。</li><li><code>Args</code> 是函数的参数类型。<br>定义一个<code>std::function</code>对象很简单，就是将可调用对象的返回值类型和参数类型作为模板参数传递给<code>std::function</code>模板类。比如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::function&lt;函数类型&gt;</span><br>std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; functional1;<br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; functional2;<br></code></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>std::function</code>的使用有多态和万总归一的感觉，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-keyword">auto</span> lamdaExps = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 1.类成员函数</span><br><span class="hljs-comment">// 2.类静态成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">classMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">staticMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 普通函数</span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; functional = testFun;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 普通函数指针</span><br>functional = &amp;testFun;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span> ,<span class="hljs-number">20</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数指针：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// Lambda表达式</span><br>functional = lamdaExps;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Lambda表达式：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 仿函数</span><br>Functor testFunctor;<br>functional = testFunctor;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;仿函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 类成员函数（使用std::bind绑定类成员函数）</span><br>TestClass testObj;<br>functional = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><span class="hljs-comment">// 类静态成员函数</span><br>functional = TestClass::staticMemberFun;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">60</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类静态成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可见<code>std::function</code>的使用其实是很简单的，只要创建一个函数或者类对象，并传入相应的参数就可以存储任何具有相同返回值和参数的可调用对象，在调用的时候直接将<code>std::function</code>对象加上 <code>()</code> 或加上相应参数就可以调用存储在其中的可调用实体。结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">普通函数：<span class="hljs-number">20</span><br>普通函数指针：<span class="hljs-number">30</span><br>Lambda表达式：<span class="hljs-number">40</span><br>仿函数：<span class="hljs-number">50</span><br>类成员函数：<span class="hljs-number">60</span><br>类静态成员函数：<span class="hljs-number">70</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>weak_ptr和unique_ptr</title>
    <link href="/2024/01/02/weak-ptr%E5%92%8Cunique-ptr/"/>
    <url>/2024/01/02/weak-ptr%E5%92%8Cunique-ptr/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576078.html">https://www.cnblogs.com/linuxAndMcu/p/14576078.html</a></p></blockquote><h1 id="weak-ptr和unique-ptr"><a href="#weak-ptr和unique-ptr" class="headerlink" title="weak_ptr和unique_ptr"></a>weak_ptr和unique_ptr</h1><h2 id="weak-ptr弱引用的智能指针"><a href="#weak-ptr弱引用的智能指针" class="headerlink" title="weak_ptr弱引用的智能指针"></a>weak_ptr弱引用的智能指针</h2><h3 id="shared-ptr相互引用会有什么后果？"><a href="#shared-ptr相互引用会有什么后果？" class="headerlink" title="shared_ptr相互引用会有什么后果？"></a>shared_ptr相互引用会有什么后果？</h3><p><code>shared_ptr</code>的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏。看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;  <span class="hljs-comment">// Parent类的前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::shared_ptr&lt;Parent&gt; father;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello Parent&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::shared_ptr&lt;Child&gt; son;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Parent&gt; <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;  <span class="hljs-comment">// 1  资源A</span><br>    <span class="hljs-function">std::shared_ptr&lt;Child&gt; <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;  <span class="hljs-comment">// 2   资源B</span><br>    parent-&gt;son = child;     <span class="hljs-comment">// 3   child.use_count() == 2 and parent.use_count() == 1 </span><br>    child-&gt;father = parent;  <span class="hljs-comment">// 4   child.use_count() == 2 and parent.use_count() == 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">hello Parent</span><br><span class="hljs-comment">hello child</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>很惊讶的发现，用了<code>shared_ptr</code>管理资源，没有调用 <code>Parent</code>和 <code>Child</code> 的析构函数，表示资源最后还是没有释放！内存泄漏还是发生了。</p><p>分析：</p><ul><li>执行编号<code>1</code>的语句时，构造了一个共享智能指针<code>p</code>，称呼它管理的资源叫做资源<code>A（new Parent()</code>产生的对象）吧， 语句<code>2</code>构造了一个共享智能指针<code>c</code>，管理资源<code>B(new Child()</code>产生的对象)，此时资源<code>A</code>和<code>B</code>的引用计数都是<code>1</code>，因为只有<code>1</code>个智能指针管理它们，执行到了语句<code>3</code>的时候，是一个智能指针的赋值操作，资源<code>B</code>的引用计数变为了<code>2</code>，同理，执行完语句<code>4</code>，资源<code>A</code>的引用计数也变成了<code>2</code>。</li><li>出了函数作用域时，由于析构和构造的顺序是相反的，会先析构共享智能指针<code>c</code>，资源<code>B</code>的引用计数就变成了<code>1</code>；接下来继续析构共享智能指针<code>p</code>，资源<code>A</code>的引用计数也变成了<code>1</code>。由于资源<code>A</code>和<code>B</code>的引用计数都不为<code>1</code>，说明还有共享智能指针在使用着它们，所以不会调用资源的析构函数！</li><li>这种情况就是个死循环，如果资源<code>A</code>的引用计数想变成<code>0</code>，则必须资源<code>B</code>先析构掉（从而析构掉内部管理资源<code>A</code>的共享智能指针），资源<code>B</code>的引用计数想变为<code>0</code>，又得依赖资源<code>A</code>的析构，这样就陷入了一个死循环。</li></ul><h3 id="weak-ptr如何解决相互引用的问题"><a href="#weak-ptr如何解决相互引用的问题" class="headerlink" title="weak_ptr如何解决相互引用的问题"></a>weak_ptr如何解决相互引用的问题</h3><p>要想解决上面循环引用的问题，只能引入新的智能指针<code>std::weak_ptr</code>。<code>std::weak_ptr</code>有什么特点呢？与<code>std::shared_ptr</code>最大的差别是在赋值的时候，不会引起智能指针计数增加。</p><ul><li><p><code>weak_ptr</code>被设计为与<code>shared_ptr</code>共同工作，可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的构造不会引起指针引用计数的增加。</p></li><li><p>同样，在<code>weak_ptr</code>析构时也不会导致引用计数的减少，它只是一个静静地观察者。<code>weak_ptr</code>没有重载<code>operator*</code>和<code>-&gt;</code>，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。</p></li><li><p>如要操作资源，则必须使用一个非常重要的成员函数<code>lock()</code>从被观测的<code>shared_ptr</code>获得一个可用的<code>shared_ptr</code>对象，从而操作资源。<br>当我们创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// wp弱共享p; p的引用计数未改变</span><br></code></pre></td></tr></table></figure><p>我们在上面的代码基础上使用<code>std::weak_ptr</code>进行修改，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;  <span class="hljs-comment">// Parent类的前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    <span class="hljs-comment">// 测试函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;testWork()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    std::weak_ptr&lt;Parent&gt; father;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello Parent&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::weak_ptr&lt;Child&gt; son;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Parent&gt; <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Child&gt; <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;<br>    parent-&gt;son = child;<br>    child-&gt;father = parent;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;parent_ref:&quot;</span> &lt;&lt; parent.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;child_ref:&quot;</span> &lt;&lt; child.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 把std::weak_ptr类型转换成std::shared_ptr类型，以调用内部成员函数</span><br>    std::shared_ptr&lt;Child&gt; tmp = parent.<span class="hljs-built_in">get</span>()-&gt;son.<span class="hljs-built_in">lock</span>();<br>    tmp-&gt;<span class="hljs-built_in">testWork</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;tmp_ref:&quot;</span> &lt;&lt; tmp.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">hello Parent</span><br><span class="hljs-comment">hello child</span><br><span class="hljs-comment">parent_ref:1</span><br><span class="hljs-comment">child_ref:1</span><br><span class="hljs-comment">testWork()</span><br><span class="hljs-comment">tmp_ref:2</span><br><span class="hljs-comment">bye child</span><br><span class="hljs-comment">bye parent</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>由以上代码运行结果我们可以看到：</p></li><li><p>所有的对象最后都能正常释放，不会存在上一个例子中的内存没有释放的问题;</p></li><li><p><code>parent</code> 和 <code>child</code> 在 <code>main</code> 函数中退出前，引用计数均为 <code>1</code>，也就是说，对<code>std::weak_ptr</code>的相互引用，不会导致计数的增加。</p></li></ul><h3 id="weak-ptr常用操作"><a href="#weak-ptr常用操作" class="headerlink" title="weak_ptr常用操作"></a>weak_ptr常用操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr&lt;T&gt; w;<span class="hljs-comment">// 空weak_ptr可以指向类型为T的对象</span><br><span class="hljs-function">weak_ptr&lt;T&gt; <span class="hljs-title">w</span><span class="hljs-params">(shared_ptr p)</span></span>;<span class="hljs-comment">// 与p指向相同对象的weak_ptr, T必须能转换为sp指向的类型</span><br>w = p;<span class="hljs-comment">// p可以是shared_ptr或者weak_ptr，赋值后w和p共享对象</span><br>w.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// weak_ptr置为空</span><br>w.<span class="hljs-built_in">use_count</span>();<span class="hljs-comment">// 与w共享对象的shared_ptr的计数</span><br>w.<span class="hljs-built_in">expired</span>();<span class="hljs-comment">// w.use_count()为0则返回true，否则返回false</span><br>w.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">// w.expired()为true，返回空的shared_ptr;否则返回指向w的shared_ptr</span><br></code></pre></td></tr></table></figure><h2 id="unique-ptr独占的智能指针"><a href="#unique-ptr独占的智能指针" class="headerlink" title="unique_ptr独占的智能指针"></a>unique_ptr独占的智能指针</h2><h3 id="unique-ptr的基本使用"><a href="#unique-ptr的基本使用" class="headerlink" title="unique_ptr的基本使用"></a>unique_ptr的基本使用</h3><p><code>unique_ptr</code>相对于其他两个智能指针更加简单，它和<code>shared_ptr</code>使用差不多，但是功能更为单一，它是一个独占型的智能指针，不允许其他的智能指针共享其内部的指针，更像原生的指针（但更为安全，能够自己释放内存）。不允许赋值和拷贝操作，只能够移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">0</span>))</span></span>;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1; <span class="hljs-comment">// 错误，不能复制</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// 可以移动</span><br></code></pre></td></tr></table></figure><p>在 <code>C++11</code> 中，没有类似<code>std::make_shared</code>的初始化方法，但是在 <code>C++14</code> 中，对于<code>std::unique_ptr</code>引入了<code>std::make_unique</code>方法进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;std::string&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string(<span class="hljs-string">&quot;unique_ptr&quot;</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;<br><br>    std::unique_ptr&lt;std::string&gt; ptr2 = std::<span class="hljs-built_in">make_unique</span>&lt;std::string&gt;(<span class="hljs-string">&quot;make_unique init!&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr2 is &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">ptr1 is unique_ptr</span><br><span class="hljs-comment">ptr2 is make_unique init!</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h3 id="unique-ptr常用操作"><a href="#unique-ptr常用操作" class="headerlink" title="unique_ptr常用操作"></a>unique_ptr常用操作</h3><p>下面列出了unique_ptr特有的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;T&gt; u1 <span class="hljs-comment">// 空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针</span><br>unique_ptr&lt;T, D&gt; u2 <span class="hljs-comment">// u2会使用一个类型为D的可调用对象来释放它的指针</span><br><span class="hljs-function">unique_ptr&lt;T, D&gt; <span class="hljs-title">u</span><span class="hljs-params">(d)</span> <span class="hljs-comment">// 空unique_ptr，指向类型为T的对象，用类型为D的对象d替代delete</span></span><br><span class="hljs-function">u </span>= <span class="hljs-literal">nullptr</span> <span class="hljs-comment">// 释放u指向的对象，将u置为空</span><br>u.<span class="hljs-built_in">release</span>() <span class="hljs-comment">// u放弃对指针的控制权，返回指针，并将u置为空</span><br>u.<span class="hljs-built_in">reset</span>() <span class="hljs-comment">// 释放u指向的对象</span><br>u.<span class="hljs-built_in">reset</span>(q) <span class="hljs-comment">// 如果提供了内置指针q，另u指向这个对象；否则将u置为空</span><br>u.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>)   <br><br></code></pre></td></tr></table></figure><p>虽然我们不能拷贝或赋值<code>unique_ptr</code>，但可以通过调用 <code>release</code> 或 <code>reset</code> 将指针的所有权从一个<code>（非const）unique_ptr</code>转移给另一个<code>unique_ptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Stegosaurus&quot;</span>))</span></span>;<br><span class="hljs-comment">// 将所有权从pl (指向string Stegosaurus)转移给p2 </span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1, release())</span></span>; <span class="hljs-comment">// release 将 p1 置为空 </span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br><br><span class="hljs-comment">// 将所有权从p3转移给p2</span><br>p2.<span class="hljs-built_in">reset</span>(p3.<span class="hljs-built_in">release</span>()); <span class="hljs-comment">// reset 释放了 p2 原来指向的内存</span><br><br></code></pre></td></tr></table></figure><p>调用 <code>release</code> 会切断<code>unique_ptr</code>和它原来管理的对象间的联系，如果我们不用另一个智能指针来保存 <code>release</code> 返回的指针，我们的程序就要负责资源的释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">p2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 错误：p2不会释放内存，而且我们丢失了指针</span><br><span class="hljs-keyword">auto</span> p = p2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 正确，但我们必须记得 delete(p)</span><br><span class="hljs-built_in">delete</span>(p);<br></code></pre></td></tr></table></figure><h3 id="传递unique-ptr参数和返回unique-ptr"><a href="#传递unique-ptr参数和返回unique-ptr" class="headerlink" title="传递unique_ptr参数和返回unique_ptr"></a>传递unique_ptr参数和返回unique_ptr</h3><p>**不能拷贝 <code>unique_ptr</code> 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 <code>unique_ptr</code>**。最常见的例子是从函数返回一个<code>unique_ptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span> <span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> (p))</span></span>;<br><span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于上面这段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，在《C++ Primer》13.6.2节（第473页）中有介绍。</p><h2 id="性能与安全的权衡"><a href="#性能与安全的权衡" class="headerlink" title="性能与安全的权衡"></a>性能与安全的权衡</h2><p>使用智能指针虽然能够解决内存泄漏问题，但是也付出了一定的代价。以<code>shared_ptr</code>举例：</p><ul><li><code>shared_ptr</code>的大小是原始指针的两倍，因为它的内部有一个原始指针指向资源，同时有个指针指向引用计数。<br>引用计数的内存必须动态分配。虽然一点可以使用<code>make_shared()</code>来避免，但也存在一些情况下不能够使用<code>make_shared()</code>。</li><li>增加和减小引用计数必须是原子操作，因为可能会有读写操作在不同的线程中同时发生。比如在一个线程里有一个指向一块资源的<code>shared_ptr</code>可能调用了析构（因此所指向的资源的引用计数减一），同时，在另一线程里，指向相同对象的一个<code>shared_ptr</code>可能执行了拷贝操作（因此，引用计数加一）。原子操作一般会比非原子操作慢。但是为了线程安全，又不得不这么做，这就给单线程使用环境带来了不必要的困扰。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shared_ptr共享的智能指针</title>
    <link href="/2024/01/02/shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/01/02/shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576049.html">https://www.cnblogs.com/linuxAndMcu/p/14576049.html</a></p></blockquote><h1 id="shared-ptr共享的智能指针"><a href="#shared-ptr共享的智能指针" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h1><p>C++ 程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。但使用普通指针，容易造成内存泄露（忘记释放）、二次释放、程序发生异常时内存泄露等问题等。所有 C++11 就引入了智能指针。</p><h2 id="原始指针容易发生内存泄漏"><a href="#原始指针容易发生内存泄漏" class="headerlink" title="原始指针容易发生内存泄漏"></a>原始指针容易发生内存泄漏</h2><p>C 语言中最常使用的是<code>malloc()</code>函数分配内存，<code>free()</code>函数释放内存，而 C++ 中对应的是<code>new</code>、<code>delete</code>关键字。<code>malloc()</code>只是分配了内存，而<code>new</code>则更进一步，不仅分配了内存，还调用了构造函数进行初始化。使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// malloc返回值是 void*</span><br>    <span class="hljs-type">int</span>* argC = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">free</span>(argC);<br><br>    <span class="hljs-type">char</span> *age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">25</span>); <span class="hljs-comment">// 做了两件事情 1.分配内存 2.初始化</span><br>    <span class="hljs-keyword">delete</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>new</code>和<code>delete</code>必须成对出现，有时候是不小心忘记了<code>delete</code>，有时候则是很难判断在这个地方自己是不是该<code>delete</code>，这个和资源的生命周期有关，这个资源是属于我这个类管理的还是由另外一个类管理的（其它类可能要使用），如果是别人管理的就由别人<code>delete</code>。</p><p>如果需要自己管理内存的话，最好显示的将自己的资源传递进去，这样的话，就能知道是该资源确实应该由自己来管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-type">char</span>* v, <span class="hljs-type">size_t</span> bufferSize)</span> </span>&#123;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面还是小问题，自己小心一点，再仔细看看文档，还是有机会避免这些情况的。但是在 C++ 引入异常的概念之后，程序的控制流就发生了根本性的改变，在写了 delete 的时候还是有可能发生内存泄漏。如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badThing</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 抛出一个异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1000</span>];<br><br>    <span class="hljs-built_in">badThing</span>();<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">delete</span>[] a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error happened &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>new</code>和<code>delete</code>是成对出现的，但是程序在中间的时候抛出了异常，由于没有立即捕获，程序从这里退出了，并没有执行到<code>delete</code>，内存泄漏还是发生了。</p><h2 id="使用构造函数和析构函数解决内存泄漏"><a href="#使用构造函数和析构函数解决内存泄漏" class="headerlink" title="使用构造函数和析构函数解决内存泄漏"></a>使用构造函数和析构函数解决内存泄漏</h2><p>C++ 中的构造函数和析构函数十分强大，可以使用构造和析构解决上面的内存泄漏问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeIntPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeIntPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : m_value(new int(v)) &#123;</span> &#125;<br>    ~<span class="hljs-built_in">SafeIntPointer</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_value;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~SafeIntPointer&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_value; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badThing</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 抛出一个异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeIntPointer <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-built_in">badThing</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error happened &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// ~SafeIntPointer</span><br><span class="hljs-comment">// error happened 1</span><br><br></code></pre></td></tr></table></figure><p>可以看到，就算发生了异常，也能够保证析构函数成功执行！<strong>这里的例子是这个资源只有一个人使用，我不用了就将它释放掉。但还有种情况，一份资源被很多人共同使用，要等到所有人都不再使用的时候才能释放掉</strong>，对于这种问题，就需要对上面的<code>SafeIntPointer</code>增加一个引用计数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeIntPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeIntPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : m_value(new int(v)), m_used(new int(<span class="hljs-number">1</span>)) &#123;</span> &#125;<br>    ~<span class="hljs-built_in">SafeIntPointer</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~SafeIntPointer&quot;</span> &lt;&lt; endl;<br>        (*m_used) --; <span class="hljs-comment">// 引用计数减1</span><br>        <span class="hljs-keyword">if</span>(*m_used &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_used;<br>            <span class="hljs-keyword">delete</span> m_value;<br>            cout &lt;&lt; <span class="hljs-string">&quot;real delete resources&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">SafeIntPointer</span>(<span class="hljs-type">const</span> SafeIntPointer&amp; other) &#123;<br>        m_used = other.m_used;<br>        m_value = other.m_value;<br>        (*m_used)++; <span class="hljs-comment">// 引用计数加1</span><br>    &#125;<br>    SafeIntPointer&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> SafeIntPointer&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-comment">// 避免自我赋值!!</span><br>           <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        m_used = other.m_used;<br>        m_value = other.m_value;<br>        (*m_used)++; <span class="hljs-comment">// 引用计数加1</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_value; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRefCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *m_used;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_used; <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span>* m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeIntPointer <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>    SafeIntPointer b = a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>    SafeIntPointer c = b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ref count = 1</span><br><span class="hljs-comment">ref count = 2</span><br><span class="hljs-comment">ref count = 3</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">real delete resources</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以看到每一次赋值，引用计数都加一，最后每次析构一次后引用计数减一，知道引用计数为 0，才真正释放资源。要写出一个正确的管理资源的包装类还是蛮难的，比如上面那个例子就不是线程安全的，只能属于一个玩具，在实际工程中简直没法用。</p><p>所以 C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得智能指针实质是一个对象，行为表现的却像一个指针。</p><p>智能指针主要分为<code>shared_ptr</code>、<code>unique_ptr</code>和<code>weak_ptr</code>三种，使用时需要引用头文件<code>&lt;memory&gt;</code>。C++98 中还有<code>auto_ptr</code>，基本被淘汰了，不推荐使用。而 C++11 中<code>shared_ptr</code>和<code>weak_ptr</code>都是参考boost库实现的。</p><h2 id="shared-ptr共享的智能指针-1"><a href="#shared-ptr共享的智能指针-1" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h2><h3 id="shared-ptr的初始化"><a href="#shared-ptr的初始化" class="headerlink" title="shared_ptr的初始化"></a>shared_ptr的初始化</h3><p>**最安全的分配和使用动态内存的方法是调用一个名为 <code>make_shared</code> 的标准库函数。 此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>**。与智能指针一样，<code>make_shared</code> 也定义在头文件 <code>memory</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// p4 指向一个值为&quot;9999999999&quot;的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<br><br><span class="hljs-comment">// p5指向一个值初始化的int</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();<br></code></pre></td></tr></table></figure><p>我们还可以用 <code>new</code> 返回的指针来初始化智能指针，不过接受指针参数的智能指针构造函数是 <code>explicit</code> 的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (<span class="hljs-number">1024</span>); <span class="hljs-comment">// 错误：必须使用直接初始化形式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure><p>出于相同的原因，一个返回 <code>shared_ptr</code> 的函数不能在其返回语句中隐式转换一个普通指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p); <span class="hljs-comment">// 错误：隐式转换为 shared_ptr&lt;int&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr的基本使用"><a href="#shared-ptr的基本使用" class="headerlink" title="shared_ptr的基本使用"></a>shared_ptr的基本使用</h3><p><code>std::shared_ptr</code>的基本使用很简单，看几个例子就明白了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;Test&gt; p1 = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#123;<br>        std::shared_ptr&lt;Test&gt; p2 = p1;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;2 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Test</span>()<br><span class="hljs-number">1</span> ref:<span class="hljs-number">1</span><br><span class="hljs-number">2</span> ref:<span class="hljs-number">2</span><br><span class="hljs-number">3</span> ref:<span class="hljs-number">1</span><br>~<span class="hljs-built_in">Test</span>()<br></code></pre></td></tr></table></figure><p>针对代码解读如下：</p><ul><li><code>std::make_shared</code>里面调用了 <code>new</code> 操作符分配内存；</li><li>第二个<code>p1.use_count()</code>之所以显示为 <code>2</code>，是因为增加了引用对象 <code>p2</code>，而随着大括号的结束，<code>p2</code> 的作用域结束，所以 <code>p1</code> 的引用计数变回 <code>1</code>，而随着 <code>main</code> 函数的结束，<code>p1</code> 的作用域结束，此时检测到计数为 <code>1</code>，那就会在销毁 <code>p1</code> 的同时，调用 <code>p1</code> 的析构函数 <code>delete</code> 掉之前分配的内存空间；</li></ul><h3 id="shared-ptr常用操作"><a href="#shared-ptr常用操作" class="headerlink" title="shared_ptr常用操作"></a>shared_ptr常用操作</h3><p>下面列出了<code>shared_ptr</code>独有的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">make_shared</span>&lt;T&gt;(args) <span class="hljs-comment">// 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(q)</span> <span class="hljs-comment">// p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能转换成T*</span></span><br><span class="hljs-function">p </span>= q <span class="hljs-comment">// p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数变为0，则将其管理的原内存释放</span><br>p.<span class="hljs-built_in">unique</span>() <span class="hljs-comment">// 若p.use_count()为1，返回true；否则返回false</span><br>p.<span class="hljs-built_in">use_count</span>() <span class="hljs-comment">// 返回与p共享对象的智能指针数量；可能很慢，主要用于调试</span><br></code></pre></td></tr></table></figure><p>下面介绍一些改变<code>shared_ptr</code>的其他方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">p.<span class="hljs-built_in">reset</span> () <span class="hljs-comment">//若p是唯一指向其对象的shared_ptr，reset会释放此对象。</span><br>p.<span class="hljs-built_in">reset</span>(q) <span class="hljs-comment">//若传递了可选的参数内置指针q，会令P指向q，否则会将P置为空。</span><br>p.<span class="hljs-built_in">reset</span>(q, d) <span class="hljs-comment">//若还传递了参数d,将会调用d而不是delete 来释放q</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async执行异步任务</title>
    <link href="/2024/01/02/async%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/01/02/async%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14577285.html">https://www.cnblogs.com/linuxAndMcu/p/14577285.html</a></p></blockquote><h1 id="async执行异步任务"><a href="#async执行异步任务" class="headerlink" title="async执行异步任务"></a>async执行异步任务</h1><h2 id="std-aysnc介绍"><a href="#std-aysnc介绍" class="headerlink" title="std::aysnc介绍"></a>std::aysnc介绍</h2><p><code>std::async</code>用于创建异步任务，实际上就是创建一个线程异步执行相应任务，它接受回调（即函数或函数对象）作为参数。</p><p><code>std::async</code>就是异步编程的高级封装，相当于封装了<code>std::promise</code>、<code>std::packaged_task</code>加上<code>std::thread</code>，基本上可以代替<code>std::thread</code>的所有事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>future&lt;<span class="hljs-keyword">typename</span> result_of&lt;<span class="hljs-built_in">Fn</span>(Args...)&gt;::type&gt; <span class="hljs-built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><p><code>std::async</code>返回一个<code>std::future</code>，该值存储由<code>std::async</code>执行的函数对象返回的值。</p><p><code>std::async</code>中的第一个参数是启动策略，它控制<code>std::async</code>的异步行为。我们可以使用 3 种不同的启动策略来创建，即：</p><ul><li><code>std::launch::async</code>：它保证了异步行为，即传递的函数将在单独的线程中执行。</li><li><code>std::launch::deferred</code>：非异步行为，即当其他线程将来调用 get() 以访问共享状态时，将调用 Function。</li><li><code>std::launch::async | std::launch::deferred</code>：它是默认行为。使用此启动策略，它可以异步运行或不异步运行，具体取决于系统上的负载。但是我们无法控制它。</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>假设我们必须从数据库中获取一些数据（字符串），并从文件系统中的文件中获取一些数据。然后，我需要合并两个字符串并进行打印。</p><p>在单线程中，我们这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromDB</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理创建数据库连接、获取数据等事情</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromFile</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理获取文件数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 获取开始时间</span><br>std::chrono::system_clock::time_point start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-comment">// 从数据库获取数据</span><br>std::string dbData = <span class="hljs-built_in">fetchDataFromDB</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">// 从文件获取数据</span><br>std::string fileData = <span class="hljs-built_in">fetchDataFromFile</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">// 获取结束时间</span><br><span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 计算消耗时间</span><br><span class="hljs-keyword">auto</span> diff = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 组装数据</span><br>std::string data = dbData + <span class="hljs-string">&quot; :: &quot;</span> + fileData;<br><span class="hljs-comment">// 输出组装的数据</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Total Time Taken  = 10 Seconds</span><br><span class="hljs-comment">Data = DB_Data :: File_Data</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>由于两个函数<code>fetchDataFromDB()</code>和<code>fetchDataFromFile()</code>均需要 5 秒钟，并且都在单个线程中运行，因此，消耗的总时间将为 10 秒钟。</p><p>现在，从数据库和文件中获取数据是彼此独立的，而且非常耗时。因此，我们可以并行运行它们。有两种方法：</p><p>一种方式是创建一个新的线程传递一个<code>promise</code>作为线程函数的参数，并在调用线程中从关联的<code>std::future</code>对象获取数据。<br>另一种简单的方法是使用<code>std::async</code>。</p><h2 id="使用函数指针调用std-async作为回调"><a href="#使用函数指针调用std-async作为回调" class="headerlink" title="使用函数指针调用std::async作为回调"></a>使用函数指针调用std::async作为回调</h2><p>现在让我们修改上面的代码，并使用<code>std::async</code>异步调用<code>fetchDataFromDB()</code>，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;std::string&gt;resultFromDB = std::<span class="hljs-built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="hljs-string">&quot;Data&quot;</span>);<br><br>std::string dbData = resultDromDB.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><p><code>std::async()</code>做以下事情：</p><ul><li>它会自动为我们创建一个线程（或从内部线程池中选择）和一个 <code>promise</code> 对象。</li><li>然后将 <code>std::promise</code> 对象传递给线程函数，并返回关联的 <code>std::future</code> 对象。</li><li>当我们传递的参数函数退出时，其值将在此 <code>promise</code> 对象中设置，因此最终返回值将在 <code>std::future</code> 对象中可用。<br>现在更改上面的示例，并使用<code>std::async</code>从数据库异步读取数据，即：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromDB</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理创建数据库连接、获取数据等事情</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromFile</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理获取文件数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//获取开始时间</span><br>std::chrono::system_clock::time_point start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-comment">// 创建异步线程，从数据库获取数据</span><br>std::future&lt;std::string&gt; resultFromDB = std::<span class="hljs-built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">//从文件获取数据</span><br>std::string fileData = <span class="hljs-built_in">fetchDataFromFile</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><br><span class="hljs-comment">//从DB获取数据</span><br><span class="hljs-comment">//数据在future&lt;std::string&gt;对象中可获取之前，将一直阻塞</span><br>std::string dbData = resultFromDB.<span class="hljs-built_in">get</span>();<br><span class="hljs-comment">//获取结束时间</span><br><span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 计算消耗时间</span><br><span class="hljs-keyword">auto</span> diff = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 组装数据</span><br>std::string data = dbData + <span class="hljs-string">&quot; :: &quot;</span> + fileData;<br><span class="hljs-comment">// 输出组装的数据</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Total Time Taken  = 5 Seconds</span><br><span class="hljs-comment">Data = DB_Data :: File_Data</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>因为有一个任务是异步的，在 5 秒内可以同时执行完两个任务。</li></ul><h2 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h2><p><code>std::async</code>使用一个 <code>callable</code> 作为一个工作包。在本例中，它可以是个函数、函数对象或者匿名函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">helloFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloFunctionObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::string <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 带函数的future</span><br><span class="hljs-keyword">auto</span> futureFunction = std::<span class="hljs-built_in">async</span>(helloFunction, <span class="hljs-string">&quot;function&quot;</span>);<br><br><span class="hljs-comment">// 带函数对象的future</span><br>HelloFunctionObject helloFunctionObject;<br><span class="hljs-keyword">auto</span> futureFunctionObject = std::<span class="hljs-built_in">async</span>(helloFunctionObject, <span class="hljs-string">&quot;function object&quot;</span>);<br><br><span class="hljs-comment">// 带匿名函数的future</span><br><span class="hljs-keyword">auto</span> futureLambda = std::<span class="hljs-built_in">async</span>([](<span class="hljs-type">const</span> std::string&amp; s) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>; &#125;, <span class="hljs-string">&quot;lambda function&quot;</span>);<br><br>std::cout &lt;&lt; futureFunction.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>&lt;&lt; futureFunctionObject.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>&lt;&lt; futureLambda.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; std::endl;<br><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Hello C++11 from function.</span><br><span class="hljs-comment">Hello C++11 from function object.</span><br><span class="hljs-comment">Hello C++11 from lambda function.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>std::async</code>调用在两端的 <code>future</code>和 <code>promise</code> 创建了一个数据通道。通过 <code>future</code> 的 <code>get()</code> 调用，<code>future</code> 收到了它的工作包的返回值。</p><p>std::async也可以绑定类成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//myClass的一个实例</span><br>    myClass obj;<br><br>　　 <span class="hljs-comment">//利用std::bind绑定类的成员函数</span><br>    <span class="hljs-keyword">auto</span> func = std::<span class="hljs-built_in">bind</span>(&amp;myClass::test, obj);<br>　　　<span class="hljs-comment">//构造future对象</span><br>    std::future&lt;<span class="hljs-type">bool</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, func);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;please wait&quot;</span>;<br>    std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">span</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (fut.<span class="hljs-built_in">wait_for</span>(span) != std::future_status::ready)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-type">bool</span> rtn = fut.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;final result: &quot;</span> &lt;&lt; rtn &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 多线程与异步调用</title>
    <link href="/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    <url>/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://yilingui.xyz/wiki/c++/cxx11_multi_thread_and_async.html">https://yilingui.xyz/wiki/c++/cxx11_multi_thread_and_async.html</a></p></blockquote><h1 id="C-11-多线程与异步调用"><a href="#C-11-多线程与异步调用" class="headerlink" title="C++11 多线程与异步调用"></a>C++11 多线程与异步调用</h1><h2 id="使用C-11线程"><a href="#使用C-11线程" class="headerlink" title="使用C++11线程"></a>使用C++11线程</h2><p>&lt;thread&gt;是 C++11 的线程库，构造函数可以传入 function pointer\functor\lambda：</p><p>使用 std::this_thread::get_id() 可以获取当前线程的 ID 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_func1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_id = std::this_thread::<span class="hljs-built_in">get_id</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;thread_func1, id: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// thread 可以接受 function pointer/functor/lambda</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func1)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">auto</span> thread_id = std::this_thread::get_id();</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;thread func lambda, id: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br><br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程的join和detach"><a href="#线程的join和detach" class="headerlink" title="线程的join和detach"></a>线程的join和detach</h2><p>join() 的含义就是等待线程完成工作，然后 join 回到当前线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func_ptr)</span></span>;<br><br>  <span class="hljs-comment">// do something (main thread)</span><br><br>  t1.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// wait thread t1 to finish its job</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，t1.join() 就是等待 t1 线程完成，然后才会继续当前线程的操作。</p><p>可以用 <code>std::this_thread::sleep_for()</code> 让线程等待一定时间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;before start thread t1\n&quot;</span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">200</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      ++i;</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-comment">// sleep 10 ms per iteration</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">      std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">10</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;   </span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;t1 finished.\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>; <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;do something in main thread.\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;wait t1 to finish.\n&quot;</span>;<br>  <span class="hljs-comment">// 主线程什么都没做，但是由于调用了 t1.join()，需要等待 t1 线程完成任务</span><br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;done.\n&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以一次创建多个线程，用一个 vector保存，注意下面 std::mem_fn 的作用是将一个类的成员函数包装成一个参数为对象的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                                                                                                                                                                         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>  &#125;;<br>  std::vector&lt;std::thread&gt; thread_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(thread_func));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;wait for all the worker thread to finish.\n&quot;</span>;<br>  std::for_each(thread_list.<span class="hljs-built_in">begin</span>(), thread_list.<span class="hljs-built_in">end</span>(),<br>                std::<span class="hljs-built_in">mem_fn</span>(&amp;std::thread::join));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>detach 的作用是创建分离线程&#x2F;后台线程&#x2F;守护线程：</p><blockquote><p>Detached threads are also called daemon &#x2F; Background threads.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>t1.<span class="hljs-built_in">detach</span>();  <span class="hljs-comment">// After calling detach(), std::thread object</span><br>              <span class="hljs-comment">// is no longer associated with the actual thread of execution.</span><br></code></pre></td></tr></table></figure><ul><li>join是阻塞当前线程，并等待 thread object 对应的线程结束，当前线程继续执行</li><li>detach 是将线程从当前线程分离出去，即不受阻塞，操作系统会将其独立对待</li></ul><p>使用 <code>detach()</code> 函数会让线程在后台运行，即说明 主线程不会等待子线程运行结束才结束 。</p><p>通常称分离线程为守护线程(daemon threads), UNIX中守护线程是指，没有任何显式的用户接口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));                     <br>    &#125;<br>  &#125;;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func)</span></span>;<br>  t1.<span class="hljs-built_in">detach</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// main thread finished.</span><br><span class="hljs-comment">// thread id: 140529165158144</span><br><span class="hljs-comment">// 可以看到主线程没有等待 t1 线程完成就结束了</span><br></code></pre></td></tr></table></figure><p>要注意，一旦调用 join() 或者 detach()，那么线程对象就不再与实际线程有关联了，要避免重复调用 join() &#x2F; detach() 。</p><p>可以用 joinable() 判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br><span class="hljs-keyword">if</span>(t1.<span class="hljs-built_in">joinable</span>()) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Detaching Thread.&quot;</span> &lt;&lt; std::endl;<br>  t1.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;<br><span class="hljs-keyword">if</span>(t2.<span class="hljs-built_in">joinable</span>()) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Joining Thread.&quot;</span> &lt;&lt; std::endl;<br>  t2.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一点要注意，不要忘记调用线程对象的 join() &#x2F; detach() 而直接 return:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    &#125;<br>  &#125;;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func)</span></span>;<br>  <span class="hljs-comment">// Program will terminate as we have&#x27;t called either join or detach with the std::thread object.</span><br>  <span class="hljs-comment">// Hence std::thread&#x27;s object destructor will terminate the program</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 RAII(Resource Acquisition Is Initialization) 对 thread 进行封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadRAII</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ThreadRAII</span>(std::thread &amp;t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br>  ~<span class="hljs-built_in">ThreadRAII</span>() &#123;<br>    <span class="hljs-keyword">if</span> (t_.<span class="hljs-built_in">joinable</span>()) &#123;<br>      t_.<span class="hljs-built_in">detach</span>();<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::thread&amp; t_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  <span class="hljs-function">ThreadRAII <span class="hljs-title">wrapper_t</span><span class="hljs-params">(t)</span></span>;  <span class="hljs-comment">// If we comment this Line, then program will crash</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传递参数给线程"><a href="#传递参数给线程" class="headerlink" title="传递参数给线程"></a>传递参数给线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> std::string &amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>  std::string str = <span class="hljs-string">&quot;hello, world&quot;</span>;<br><br>  <span class="hljs-comment">// directly pass params to std::thread&#x27;s constructor</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, x, str)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，小心传递局部变量或者动态内存的地址和指针，不同线程难以保证指针是否有效。对于真正要共享的内容，要记得 加锁 。</p><h3 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h3><p>默认传参给线程会拷贝一份参数的值到线程，即使声明了引用参数也无法改变外部变量，如何传递引用？可以用 <code>std::ref()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> &amp;y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(x);  <span class="hljs-comment">// 强制转换为非 const</span><br>  ++y;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inside thread x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, before t1 starts, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, x)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, after t1 joins, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main thread, before t1 starts, x: 9</span><br><span class="hljs-comment">inside thread x: 10</span><br><span class="hljs-comment">main thread, after t1 joins, x: 9</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 可以看到，即使声明了引用参数，也没有改变 main thread 中 x 的值</span><br></code></pre></td></tr></table></figure><p>使用 <code>std::ref</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> &amp;y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(x);  <span class="hljs-comment">// 强制转换为非 const</span><br>  ++y;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inside thread x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, before t1 starts, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, std::ref(x))</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, after t1 joins, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main thread, before t1 starts, x: 9</span><br><span class="hljs-comment">inside thread x: 10</span><br><span class="hljs-comment">main thread, after t1 joins, x: 10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="传递成员函数"><a href="#传递成员函数" class="headerlink" title="传递成员函数"></a>传递成员函数</h3><p>成员函数传递给线程，注意第一个函数参数要传实例的地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  A a;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;A::say_hello, &amp;a, <span class="hljs-string">&quot;stranger&quot;</span>)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Lock-机制处理多线程数据共享"><a href="#使用-Lock-机制处理多线程数据共享" class="headerlink" title="使用 Lock 机制处理多线程数据共享"></a>使用 Lock 机制处理多线程数据共享</h2><h3 id="Race-condition"><a href="#Race-condition" class="headerlink" title="Race condition"></a>Race condition</h3><blockquote><p>Race condition is a kind of a bug that occurs in multithreaded applications.  </p></blockquote><p>多个线程并发地访问同一个地址时，如果不做一些特殊处理，可能会引发意想不到的结果。</p><h3 id="Lock-机制"><a href="#Lock-机制" class="headerlink" title="Lock 机制"></a>Lock 机制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Count</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 多线程写操作，要加锁</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    mutex_for_x_.<span class="hljs-built_in">lock</span>();<br>    ++x_;<br>    mutex_for_x_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">()</span> </span>&#123;<br>    mutex_for_x_.<span class="hljs-built_in">lock</span>();<br>    --x_;<br>    mutex_for_x_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x_;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x_ = <span class="hljs-number">0</span>;<br>  std::mutex mutex_for_x_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Count count;<br>  std::vector&lt;std::thread&gt; thread_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>      thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Count::add, &amp;count));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Count::reduce, &amp;count));<br>    &#125;<br>  &#125;<br>  std::for_each(thread_list.<span class="hljs-built_in">begin</span>(), thread_list.<span class="hljs-built_in">end</span>(),<br>      std::<span class="hljs-built_in">mem_fn</span>(&amp;std::thread::join));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;final count: &quot;</span> &lt;&lt; count.<span class="hljs-built_in">get_count</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用 std::lock_guard，实现了对 mutex 对象的 RAII：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// lock_guard 对象出作用域会自动 unlock mutex</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_for_x_)</span></span>;<br>    ++x_;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Condition-variable-处理事件响应"><a href="#使用-Condition-variable-处理事件响应" class="headerlink" title="使用 Condition variable 处理事件响应"></a>使用 Condition variable 处理事件响应</h2><p>假设要实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程从队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。</p><p>mutex 可以完成这个任务，但是却存在着性能问题。消费者每次都要等待锁释放。如果生产者处理开销较大，那么会有不必要的等待开销。</p><p>更合适的模型是，生产者往队列中添加完数据后，立刻通知消费者干活，如何实现这种“通知”的机制？C++11 提供了 Condition variable 来帮我们实现多线程之间的 signal 机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Application</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">Application</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_data</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;loading data...\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    <span class="hljs-comment">// lock the data</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    data_loaded_ = <span class="hljs-literal">true</span>;<br>    cond_var_.<span class="hljs-built_in">notify_one</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main_proc</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main processing...\n&quot;</span>;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-comment">// Start waiting for the Condition Variable to get signaled</span><br>    <span class="hljs-comment">// wait() will internally release the lock and make the thread to block</span><br>    <span class="hljs-comment">// as soon as condition variable get signaled, resume the thread and</span><br>    <span class="hljs-comment">// again acquire the lock. Then check if condition is met or not</span><br>    <span class="hljs-comment">// if condition is met then continue else again go in wait.</span><br>    cond_var_.<span class="hljs-built_in">wait</span>(lock, [&amp;]() &#123;<br>      <span class="hljs-keyword">return</span> data_loaded_;<br>    &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main processing done.\n&quot;</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">bool</span> data_loaded_ = <span class="hljs-literal">false</span>;<br>  std::mutex mutex_;<br>  std::condition_variable cond_var_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Application app;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;Application::load_data, &amp;app)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(&amp;Application::main_proc, &amp;app)</span></span>;<br>  t2.<span class="hljs-built_in">join</span>();<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>cond_var_.wait()</code> 要和 <code>std::unique_lock</code> 配合使用，不能用 <code>std::lock_guard</code>，因为 <code>wait()</code> 函数会先调用互斥锁的 <code>unlock()</code> 函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而 <code>lock_guard</code> 没有 <code>lock</code> 和 <code>unlock</code> 接口，而 <code>unique_lock</code> 提供了。这就是必须使用 <code>unique_lock</code> 的原因。</p><p>关于 std::condition_variable 的成员函数：</p><blockquote><ul><li>wait()：It makes the current thread to block until the condition variable get signaled or a spurious wake up happens.</li><li>notify_one()：If any threads are waiting on same conditional variable object then notify_one unblocks one of the waiting threads.</li><li>notify_all()：If any threads are waiting on same conditional variable object then notify_all unblocks all of the waiting threads.</li></ul></blockquote><p>再看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>std::mutex mu;<br>std::condition_variable cond;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>    q.<span class="hljs-built_in">push_front</span>(count);<br>    locker.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 注意控制锁的粒度，q.push_front() 之后就不需要保护了，可以提前 unlock</span><br>    cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// Notify one waiting thread, if there is one.</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    --count;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( data != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">empty</span>()) &#123;<br>      cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// Unlock mutex and wait to be notified</span><br>    &#125;<br>    data = q.<span class="hljs-built_in">back</span>();<br>    q.<span class="hljs-built_in">pop_back</span>();<br>    locker.<span class="hljs-built_in">unlock</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(function_1)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(function_2)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-std-future-和-std-promise-处理线程的返回值"><a href="#使用-std-future-和-std-promise-处理线程的返回值" class="headerlink" title="使用 std::future 和 std::promise 处理线程的返回值"></a>使用 std::future 和 std::promise 处理线程的返回值</h2><p>假设我们要写一个程序，从主线程创建一个线程来压缩一个文件夹，压缩完成后在主线程打印压缩文件名和大小，要求压缩线程返回压缩文件名和文件大小。</p><p>第一种方式：通过共享指针实现，向压缩线程传入一个指针变量，利用 mutex，condition variable 完成。</p><p>第二种方式：使用 std::future 和 std::promise。</p><blockquote><ul><li>std::future is a class template and its object stores the future value .</li><li>std::promise is also a class template and its object promises to set the value in future . Each std::promise object has an associated std::future object that will give the value once set by the std::promise object.</li><li>A std::promise object shares data with its associated std::future object.</li></ul></blockquote><p>如图所示：</p><img src="/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/cxx11_promise_future.png" class="" title="cxx11_promise_future"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; * promise_obj)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Inside Thread&quot;</span> &lt;&lt; std::endl;<br>  promise_obj-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-number">42</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  std::promise&lt;<span class="hljs-type">int</span>&gt; promise_obj;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; future_obj = promise_obj.<span class="hljs-built_in">get_future</span>();<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(init, &amp;promise_obj)</span></span>;<br>  std::cout &lt;&lt; future_obj.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// blocked on the std::future::get() function</span><br>  t.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-11-异步调用"><a href="#C-11-异步调用" class="headerlink" title="C++11 异步调用"></a>C++11 异步调用</h2><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h3><p>异步操作的主要目的是 让调用方法的主线程不需要同步等待调用函数，从而可以让主线程继续执行它下面的代码 。因此异步操作无须额外的线程负担，使用回调的方式进行处理。在设计良好的情况下，处理函数可以不必或者减少使用共享变量，减少了死锁的可能。当需要执行I&#x2F;O操作时，使用异步操作比使用线程+同步I&#x2F;O操作更合适。</p><p>异步和多线程并不是一个同等关系， 异步是目的，多线程是实现异步的一个手段 。实现异步可以采用多线程或交给另外的进程来处理。</p><ul><li>std::future 可以从异步任务中获取结果，一般与 std::async 配合使用， std::async 用于创建异步任务，实际上就是创建一个线程执行相应任务。</li><li>std::async 就是异步编程的高级封装，封装了 std::future 的操作，基本上可以代替 std::thread 的所有事情</li><li>std::async 的操作，其实相当于封装了 std::promise 、 std::packaged_task 加上 std::thread 。<blockquote><p>std::async： std::async() is a function template that accepts a callback(i.e. function or function object) as an argument and potentially executes them asynchronously.</p></blockquote></li></ul><p>std::async 的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>future&lt;<span class="hljs-keyword">typename</span> result_of&lt;<span class="hljs-built_in">Fn</span>(Args...)&gt;::type&gt; <span class="hljs-built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><blockquote><p>std::async returns a std::future<T>, that stores the value returned by function object executed by std::async(). Arguments expected by function can be passed to std::async() as arguments after the function pointer argument.<br>First argument in std::async is launch policy, it control the asynchronous behaviour of std::async .</p></blockquote><ul><li>std::launch::async ，调用即创建线程，在另一个 thread 中执行任务</li><li>std::launch::deferred ，延迟加载方式创建线程，调用时不创建线程，直到调用 future 的 get 或者 wait 时才创建线程(lazy evaluation)</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_data_from_db</span><span class="hljs-params">(std::string recvd_data)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvd_data;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_data_from_file</span><span class="hljs-params">(std::string recvd_data)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvd_data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  system_clock::time_point start = system_clock::<span class="hljs-built_in">now</span>();<br><br>  <span class="hljs-comment">// 异步调用，std::launch::async 策略，会立即创建一个线程工作</span><br>  <span class="hljs-comment">// 如果改成 std::launch::deferred，那么这个例子就看不到使用异步加速的效果了</span><br>  std::future&lt;std::string&gt; result_from_db =<br>      std::<span class="hljs-built_in">async</span>(std::launch::async, fetch_data_from_db, <span class="hljs-string">&quot;Data&quot;</span>);<br><br>  <span class="hljs-comment">// Fetch Data from File</span><br>  std::string file_data = <span class="hljs-built_in">fetch_data_from_file</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><br>  <span class="hljs-comment">// Fetch Data from DB</span><br>  <span class="hljs-comment">// Will block till data is available in future&lt;std::string&gt; object.</span><br>  std::string db_data = result_from_db.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">auto</span> end = system_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-keyword">auto</span> diff = duration_cast &lt; std::chrono::seconds &gt; (end - start).<span class="hljs-built_in">count</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time Taken = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot; Seconds&quot;</span> &lt;&lt; std::endl;<br>  std::string data = db_data + <span class="hljs-string">&quot; :: &quot;</span> + file_data;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::promise 通过 set_value 可以使得与之关联的 std::future 获取数据。 std::packaged_task 则更为强大，它允许传入一个函数，并将函数计算的结果传递给 std::future。</p><p>std::packaged_task&lt;&gt; is a class template and represents a asynchronous task. It encapsulates:</p><ul><li>A callable entity i.e either function, lambda function or function object.</li><li>A shared state that stores the value returned or thrown exception by associated callback.</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(sum)</span></span>;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; future = task.<span class="hljs-built_in">get_future</span>();<br><br>  <span class="hljs-comment">// std::promise 一样，std::packaged_task 支持 move，但不支持拷贝</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(std::move(task), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-comment">// 等待异步计算结果</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 =&gt; &quot;</span> &lt;&lt; future.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>  t.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-std-future-和-std-promise-实现终止线程功能"><a href="#使用-std-future-和-std-promise-实现终止线程功能" class="headerlink" title="使用 std::future 和 std::promise 实现终止线程功能"></a>使用 std::future 和 std::promise 实现终止线程功能</h2><p>我们希望能显式控制一个进程的终止，该如何实现？前面提到过了 std::promise 和 std::future，只有当 promise 设置值的时候 future 才会真正获取值，那么可以把 promise::set_value 作为一个通知信号来使用，，检查 future 的状态就知道是不是要结束线程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">void</span>&gt; future_obj)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread Start&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 利用 std::future::wait_for() 来控制循环是否终止</span><br>  <span class="hljs-comment">// 如果相应的 promise object 调用了 set_value()，那么结束循环</span><br>  <span class="hljs-keyword">while</span> (future_obj.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">0</span>)) ==<br>      std::future_status::timeout) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Doing Some Work&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread End&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Create a std::promise object</span><br>  std::promise&lt;<span class="hljs-type">void</span>&gt; exit_signal;<br><br>  <span class="hljs-comment">// Fetch std::future object associated with promise</span><br>  std::future&lt;<span class="hljs-type">void</span>&gt; future_obj = exit_signal.<span class="hljs-built_in">get_future</span>();<br><br>  <span class="hljs-comment">// Starting Thread &amp; move the future object in lambda function by reference</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;thread_callback, std::move(future_obj))</span></span>;<br><br>  <span class="hljs-comment">// Wait for 10 sec</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Asking Thread to Stop&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// Set the value in promise</span><br>  exit_signal.<span class="hljs-built_in">set_value</span>();<br><br>  <span class="hljs-comment">// Wait for thread to join</span><br>  t.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting Main Function&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用面向对象封装一个 Stoppable 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stoppable</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Stoppable</span>() : <span class="hljs-built_in">future_obj_</span>(exit_signal_.<span class="hljs-built_in">get_future</span>()) &#123;&#125;<br>  <span class="hljs-built_in">Stoppable</span>(Stoppable &amp;&amp;obj) : <span class="hljs-built_in">exit_signal_</span>(std::<span class="hljs-built_in">move</span>(obj.exit_signal_)),<br>      <span class="hljs-built_in">future_obj_</span>(std::<span class="hljs-built_in">move</span>(obj.future_obj_)) &#123;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stoppable</span>() = <span class="hljs-keyword">default</span>;<br><br>  Stoppable&amp; <span class="hljs-keyword">operator</span>=(Stoppable &amp;&amp;obj) &#123;<br>    exit_signal_ = std::<span class="hljs-built_in">move</span>(obj.exit_signal_);<br>    future_obj_ = std::<span class="hljs-built_in">move</span>(obj.future_obj_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">run</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_stop_requested</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (future_obj_.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">0</span>)) ==<br>        std::future_status::timeout) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    exit_signal_.<span class="hljs-built_in">set_value</span>();<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::promise&lt;<span class="hljs-type">void</span>&gt; exit_signal_;<br>  std::future&lt;<span class="hljs-type">void</span>&gt; future_obj_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> : <span class="hljs-keyword">public</span> Stoppable &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task Start&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">is_stop_requested</span>()) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Doing Some Work&quot;</span> &lt;&lt; std::endl;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task End&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  MyTask task;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    task.run();</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Asking Task to Stop&quot;</span> &lt;&lt; std::endl;<br>  task.<span class="hljs-built_in">stop</span>();<br>  t.<span class="hljs-built_in">join</span>();<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread Joined&quot;</span> &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting Main Function&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<img src="/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/mario.jpeg" class="" title="mario">]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mario</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
