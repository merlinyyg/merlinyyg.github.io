<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>shared_ptr共享的智能指针</title>
    <link href="/2024/01/02/shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/01/02/shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576049.html">https://www.cnblogs.com/linuxAndMcu/p/14576049.html</a></p></blockquote><h1 id="shared-ptr共享的智能指针"><a href="#shared-ptr共享的智能指针" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h1><p>C++ 程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。但使用普通指针，容易造成内存泄露（忘记释放）、二次释放、程序发生异常时内存泄露等问题等。所有 C++11 就引入了智能指针。</p><h2 id="原始指针容易发生内存泄漏"><a href="#原始指针容易发生内存泄漏" class="headerlink" title="原始指针容易发生内存泄漏"></a>原始指针容易发生内存泄漏</h2><p>C 语言中最常使用的是<code>malloc()</code>函数分配内存，<code>free()</code>函数释放内存，而 C++ 中对应的是<code>new</code>、<code>delete</code>关键字。<code>malloc()</code>只是分配了内存，而<code>new</code>则更进一步，不仅分配了内存，还调用了构造函数进行初始化。使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// malloc返回值是 void*</span><br>    <span class="hljs-type">int</span>* argC = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">free</span>(argC);<br><br>    <span class="hljs-type">char</span> *age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">25</span>); <span class="hljs-comment">// 做了两件事情 1.分配内存 2.初始化</span><br>    <span class="hljs-keyword">delete</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>new</code>和<code>delete</code>必须成对出现，有时候是不小心忘记了<code>delete</code>，有时候则是很难判断在这个地方自己是不是该<code>delete</code>，这个和资源的生命周期有关，这个资源是属于我这个类管理的还是由另外一个类管理的（其它类可能要使用），如果是别人管理的就由别人<code>delete</code>。</p><p>如果需要自己管理内存的话，最好显示的将自己的资源传递进去，这样的话，就能知道是该资源确实应该由自己来管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-type">char</span>* v, <span class="hljs-type">size_t</span> bufferSize)</span> </span>&#123;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面还是小问题，自己小心一点，再仔细看看文档，还是有机会避免这些情况的。但是在 C++ 引入异常的概念之后，程序的控制流就发生了根本性的改变，在写了 delete 的时候还是有可能发生内存泄漏。如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badThing</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 抛出一个异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1000</span>];<br><br>    <span class="hljs-built_in">badThing</span>();<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">delete</span>[] a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error happened &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>new</code>和<code>delete</code>是成对出现的，但是程序在中间的时候抛出了异常，由于没有立即捕获，程序从这里退出了，并没有执行到<code>delete</code>，内存泄漏还是发生了。</p><h2 id="使用构造函数和析构函数解决内存泄漏"><a href="#使用构造函数和析构函数解决内存泄漏" class="headerlink" title="使用构造函数和析构函数解决内存泄漏"></a>使用构造函数和析构函数解决内存泄漏</h2><p>C++ 中的构造函数和析构函数十分强大，可以使用构造和析构解决上面的内存泄漏问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeIntPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeIntPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : m_value(new int(v)) &#123;</span> &#125;<br>    ~<span class="hljs-built_in">SafeIntPointer</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_value;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~SafeIntPointer&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_value; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badThing</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 抛出一个异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeIntPointer <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-built_in">badThing</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error happened &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// ~SafeIntPointer</span><br><span class="hljs-comment">// error happened 1</span><br><br></code></pre></td></tr></table></figure><p>可以看到，就算发生了异常，也能够保证析构函数成功执行！<strong>这里的例子是这个资源只有一个人使用，我不用了就将它释放掉。但还有种情况，一份资源被很多人共同使用，要等到所有人都不再使用的时候才能释放掉</strong>，对于这种问题，就需要对上面的<code>SafeIntPointer</code>增加一个引用计数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeIntPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeIntPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : m_value(new int(v)), m_used(new int(<span class="hljs-number">1</span>)) &#123;</span> &#125;<br>    ~<span class="hljs-built_in">SafeIntPointer</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~SafeIntPointer&quot;</span> &lt;&lt; endl;<br>        (*m_used) --; <span class="hljs-comment">// 引用计数减1</span><br>        <span class="hljs-keyword">if</span>(*m_used &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_used;<br>            <span class="hljs-keyword">delete</span> m_value;<br>            cout &lt;&lt; <span class="hljs-string">&quot;real delete resources&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">SafeIntPointer</span>(<span class="hljs-type">const</span> SafeIntPointer&amp; other) &#123;<br>        m_used = other.m_used;<br>        m_value = other.m_value;<br>        (*m_used)++; <span class="hljs-comment">// 引用计数加1</span><br>    &#125;<br>    SafeIntPointer&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> SafeIntPointer&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-comment">// 避免自我赋值!!</span><br>           <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        m_used = other.m_used;<br>        m_value = other.m_value;<br>        (*m_used)++; <span class="hljs-comment">// 引用计数加1</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_value; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRefCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *m_used;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_used; <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span>* m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeIntPointer <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>    SafeIntPointer b = a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>    SafeIntPointer c = b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ref count = 1</span><br><span class="hljs-comment">ref count = 2</span><br><span class="hljs-comment">ref count = 3</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">real delete resources</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以看到每一次赋值，引用计数都加一，最后每次析构一次后引用计数减一，知道引用计数为 0，才真正释放资源。要写出一个正确的管理资源的包装类还是蛮难的，比如上面那个例子就不是线程安全的，只能属于一个玩具，在实际工程中简直没法用。</p><p>所以 C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得智能指针实质是一个对象，行为表现的却像一个指针。</p><p>智能指针主要分为<code>shared_ptr</code>、<code>unique_ptr</code>和<code>weak_ptr</code>三种，使用时需要引用头文件<code>&lt;memory&gt;</code>。C++98 中还有<code>auto_ptr</code>，基本被淘汰了，不推荐使用。而 C++11 中<code>shared_ptr</code>和<code>weak_ptr</code>都是参考boost库实现的。</p><h2 id="shared-ptr共享的智能指针-1"><a href="#shared-ptr共享的智能指针-1" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h2><h3 id="shared-ptr的初始化"><a href="#shared-ptr的初始化" class="headerlink" title="shared_ptr的初始化"></a>shared_ptr的初始化</h3><p>**最安全的分配和使用动态内存的方法是调用一个名为 <code>make_shared</code> 的标准库函数。 此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>**。与智能指针一样，<code>make_shared</code> 也定义在头文件 <code>memory</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// p4 指向一个值为&quot;9999999999&quot;的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<br><br><span class="hljs-comment">// p5指向一个值初始化的int</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();<br></code></pre></td></tr></table></figure><p>我们还可以用 <code>new</code> 返回的指针来初始化智能指针，不过接受指针参数的智能指针构造函数是 <code>explicit</code> 的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (<span class="hljs-number">1024</span>); <span class="hljs-comment">// 错误：必须使用直接初始化形式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure><p>出于相同的原因，一个返回 <code>shared_ptr</code> 的函数不能在其返回语句中隐式转换一个普通指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p); <span class="hljs-comment">// 错误：隐式转换为 shared_ptr&lt;int&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr的基本使用"><a href="#shared-ptr的基本使用" class="headerlink" title="shared_ptr的基本使用"></a>shared_ptr的基本使用</h3><p><code>std::shared_ptr</code>的基本使用很简单，看几个例子就明白了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;Test&gt; p1 = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#123;<br>        std::shared_ptr&lt;Test&gt; p2 = p1;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;2 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Test</span>()<br><span class="hljs-number">1</span> ref:<span class="hljs-number">1</span><br><span class="hljs-number">2</span> ref:<span class="hljs-number">2</span><br><span class="hljs-number">3</span> ref:<span class="hljs-number">1</span><br>~<span class="hljs-built_in">Test</span>()<br></code></pre></td></tr></table></figure><p>针对代码解读如下：</p><ul><li><code>std::make_shared</code>里面调用了 <code>new</code> 操作符分配内存；</li><li>第二个<code>p1.use_count()</code>之所以显示为 <code>2</code>，是因为增加了引用对象 <code>p2</code>，而随着大括号的结束，<code>p2</code> 的作用域结束，所以 <code>p1</code> 的引用计数变回 <code>1</code>，而随着 <code>main</code> 函数的结束，<code>p1</code> 的作用域结束，此时检测到计数为 <code>1</code>，那就会在销毁 <code>p1</code> 的同时，调用 <code>p1</code> 的析构函数 <code>delete</code> 掉之前分配的内存空间；</li></ul><h3 id="shared-ptr常用操作"><a href="#shared-ptr常用操作" class="headerlink" title="shared_ptr常用操作"></a>shared_ptr常用操作</h3><p>下面列出了<code>shared_ptr</code>独有的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">make_shared</span>&lt;T&gt;(args) <span class="hljs-comment">// 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(q)</span> <span class="hljs-comment">// p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能转换成T*</span></span><br><span class="hljs-function">p </span>= q <span class="hljs-comment">// p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数变为0，则将其管理的原内存释放</span><br>p.<span class="hljs-built_in">unique</span>() <span class="hljs-comment">// 若p.use_count()为1，返回true；否则返回false</span><br>p.<span class="hljs-built_in">use_count</span>() <span class="hljs-comment">// 返回与p共享对象的智能指针数量；可能很慢，主要用于调试</span><br></code></pre></td></tr></table></figure><p>下面介绍一些改变<code>shared_ptr</code>的其他方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">p.<span class="hljs-built_in">reset</span> () <span class="hljs-comment">//若p是唯一指向其对象的shared_ptr，reset会释放此对象。</span><br>p.<span class="hljs-built_in">reset</span>(q) <span class="hljs-comment">//若传递了可选的参数内置指针q，会令P指向q，否则会将P置为空。</span><br>p.<span class="hljs-built_in">reset</span>(q, d) <span class="hljs-comment">//若还传递了参数d,将会调用d而不是delete 来释放q</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async执行异步任务</title>
    <link href="/2024/01/02/async%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/01/02/async%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14577285.html">https://www.cnblogs.com/linuxAndMcu/p/14577285.html</a></p></blockquote><h1 id="async执行异步任务"><a href="#async执行异步任务" class="headerlink" title="async执行异步任务"></a>async执行异步任务</h1><h2 id="std-aysnc介绍"><a href="#std-aysnc介绍" class="headerlink" title="std::aysnc介绍"></a>std::aysnc介绍</h2><p><code>std::async</code>用于创建异步任务，实际上就是创建一个线程异步执行相应任务，它接受回调（即函数或函数对象）作为参数。</p><p><code>std::async</code>就是异步编程的高级封装，相当于封装了<code>std::promise</code>、<code>std::packaged_task</code>加上<code>std::thread</code>，基本上可以代替<code>std::thread</code>的所有事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>future&lt;<span class="hljs-keyword">typename</span> result_of&lt;<span class="hljs-built_in">Fn</span>(Args...)&gt;::type&gt; <span class="hljs-built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><p><code>std::async</code>返回一个<code>std::future</code>，该值存储由<code>std::async</code>执行的函数对象返回的值。</p><p><code>std::async</code>中的第一个参数是启动策略，它控制<code>std::async</code>的异步行为。我们可以使用 3 种不同的启动策略来创建，即：</p><ul><li><code>std::launch::async</code>：它保证了异步行为，即传递的函数将在单独的线程中执行。</li><li><code>std::launch::deferred</code>：非异步行为，即当其他线程将来调用 get() 以访问共享状态时，将调用 Function。</li><li><code>std::launch::async | std::launch::deferred</code>：它是默认行为。使用此启动策略，它可以异步运行或不异步运行，具体取决于系统上的负载。但是我们无法控制它。</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>假设我们必须从数据库中获取一些数据（字符串），并从文件系统中的文件中获取一些数据。然后，我需要合并两个字符串并进行打印。</p><p>在单线程中，我们这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromDB</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理创建数据库连接、获取数据等事情</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromFile</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理获取文件数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 获取开始时间</span><br>std::chrono::system_clock::time_point start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-comment">// 从数据库获取数据</span><br>std::string dbData = <span class="hljs-built_in">fetchDataFromDB</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">// 从文件获取数据</span><br>std::string fileData = <span class="hljs-built_in">fetchDataFromFile</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">// 获取结束时间</span><br><span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 计算消耗时间</span><br><span class="hljs-keyword">auto</span> diff = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 组装数据</span><br>std::string data = dbData + <span class="hljs-string">&quot; :: &quot;</span> + fileData;<br><span class="hljs-comment">// 输出组装的数据</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Total Time Taken  = 10 Seconds</span><br><span class="hljs-comment">Data = DB_Data :: File_Data</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>由于两个函数<code>fetchDataFromDB()</code>和<code>fetchDataFromFile()</code>均需要 5 秒钟，并且都在单个线程中运行，因此，消耗的总时间将为 10 秒钟。</p><p>现在，从数据库和文件中获取数据是彼此独立的，而且非常耗时。因此，我们可以并行运行它们。有两种方法：</p><p>一种方式是创建一个新的线程传递一个<code>promise</code>作为线程函数的参数，并在调用线程中从关联的<code>std::future</code>对象获取数据。<br>另一种简单的方法是使用<code>std::async</code>。</p><h2 id="使用函数指针调用std-async作为回调"><a href="#使用函数指针调用std-async作为回调" class="headerlink" title="使用函数指针调用std::async作为回调"></a>使用函数指针调用std::async作为回调</h2><p>现在让我们修改上面的代码，并使用<code>std::async</code>异步调用<code>fetchDataFromDB()</code>，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;std::string&gt;resultFromDB = std::<span class="hljs-built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="hljs-string">&quot;Data&quot;</span>);<br><br>std::string dbData = resultDromDB.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><p><code>std::async()</code>做以下事情：</p><ul><li>它会自动为我们创建一个线程（或从内部线程池中选择）和一个 <code>promise</code> 对象。</li><li>然后将 <code>std::promise</code> 对象传递给线程函数，并返回关联的 <code>std::future</code> 对象。</li><li>当我们传递的参数函数退出时，其值将在此 <code>promise</code> 对象中设置，因此最终返回值将在 <code>std::future</code> 对象中可用。<br>现在更改上面的示例，并使用<code>std::async</code>从数据库异步读取数据，即：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromDB</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理创建数据库连接、获取数据等事情</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromFile</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理获取文件数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//获取开始时间</span><br>std::chrono::system_clock::time_point start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-comment">// 创建异步线程，从数据库获取数据</span><br>std::future&lt;std::string&gt; resultFromDB = std::<span class="hljs-built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">//从文件获取数据</span><br>std::string fileData = <span class="hljs-built_in">fetchDataFromFile</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><br><span class="hljs-comment">//从DB获取数据</span><br><span class="hljs-comment">//数据在future&lt;std::string&gt;对象中可获取之前，将一直阻塞</span><br>std::string dbData = resultFromDB.<span class="hljs-built_in">get</span>();<br><span class="hljs-comment">//获取结束时间</span><br><span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 计算消耗时间</span><br><span class="hljs-keyword">auto</span> diff = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 组装数据</span><br>std::string data = dbData + <span class="hljs-string">&quot; :: &quot;</span> + fileData;<br><span class="hljs-comment">// 输出组装的数据</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Total Time Taken  = 5 Seconds</span><br><span class="hljs-comment">Data = DB_Data :: File_Data</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>因为有一个任务是异步的，在 5 秒内可以同时执行完两个任务。</li></ul><h2 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h2><p><code>std::async</code>使用一个 <code>callable</code> 作为一个工作包。在本例中，它可以是个函数、函数对象或者匿名函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">helloFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloFunctionObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::string <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 带函数的future</span><br><span class="hljs-keyword">auto</span> futureFunction = std::<span class="hljs-built_in">async</span>(helloFunction, <span class="hljs-string">&quot;function&quot;</span>);<br><br><span class="hljs-comment">// 带函数对象的future</span><br>HelloFunctionObject helloFunctionObject;<br><span class="hljs-keyword">auto</span> futureFunctionObject = std::<span class="hljs-built_in">async</span>(helloFunctionObject, <span class="hljs-string">&quot;function object&quot;</span>);<br><br><span class="hljs-comment">// 带匿名函数的future</span><br><span class="hljs-keyword">auto</span> futureLambda = std::<span class="hljs-built_in">async</span>([](<span class="hljs-type">const</span> std::string&amp; s) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>; &#125;, <span class="hljs-string">&quot;lambda function&quot;</span>);<br><br>std::cout &lt;&lt; futureFunction.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>&lt;&lt; futureFunctionObject.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>&lt;&lt; futureLambda.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; std::endl;<br><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Hello C++11 from function.</span><br><span class="hljs-comment">Hello C++11 from function object.</span><br><span class="hljs-comment">Hello C++11 from lambda function.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>std::async</code>调用在两端的 <code>future</code>和 <code>promise</code> 创建了一个数据通道。通过 <code>future</code> 的 <code>get()</code> 调用，<code>future</code> 收到了它的工作包的返回值。</p><p>std::async也可以绑定类成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//myClass的一个实例</span><br>    myClass obj;<br><br>　　 <span class="hljs-comment">//利用std::bind绑定类的成员函数</span><br>    <span class="hljs-keyword">auto</span> func = std::<span class="hljs-built_in">bind</span>(&amp;myClass::test, obj);<br>　　　<span class="hljs-comment">//构造future对象</span><br>    std::future&lt;<span class="hljs-type">bool</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, func);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;please wait&quot;</span>;<br>    std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">span</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (fut.<span class="hljs-built_in">wait_for</span>(span) != std::future_status::ready)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-type">bool</span> rtn = fut.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;final result: &quot;</span> &lt;&lt; rtn &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 多线程与异步调用</title>
    <link href="/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    <url>/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://yilingui.xyz/wiki/c++/cxx11_multi_thread_and_async.html">https://yilingui.xyz/wiki/c++/cxx11_multi_thread_and_async.html</a></p></blockquote><h1 id="C-11-多线程与异步调用"><a href="#C-11-多线程与异步调用" class="headerlink" title="C++11 多线程与异步调用"></a>C++11 多线程与异步调用</h1><h2 id="使用C-11线程"><a href="#使用C-11线程" class="headerlink" title="使用C++11线程"></a>使用C++11线程</h2><p>&lt;thread&gt;是 C++11 的线程库，构造函数可以传入 function pointer\functor\lambda：</p><p>使用 std::this_thread::get_id() 可以获取当前线程的 ID 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_func1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_id = std::this_thread::<span class="hljs-built_in">get_id</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;thread_func1, id: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// thread 可以接受 function pointer/functor/lambda</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func1)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">auto</span> thread_id = std::this_thread::get_id();</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;thread func lambda, id: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br><br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程的join和detach"><a href="#线程的join和detach" class="headerlink" title="线程的join和detach"></a>线程的join和detach</h2><p>join() 的含义就是等待线程完成工作，然后 join 回到当前线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func_ptr)</span></span>;<br><br>  <span class="hljs-comment">// do something (main thread)</span><br><br>  t1.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// wait thread t1 to finish its job</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，t1.join() 就是等待 t1 线程完成，然后才会继续当前线程的操作。</p><p>可以用 <code>std::this_thread::sleep_for()</code> 让线程等待一定时间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;before start thread t1\n&quot;</span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">200</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      ++i;</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-comment">// sleep 10 ms per iteration</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">      std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">10</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;   </span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;t1 finished.\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>; <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;do something in main thread.\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;wait t1 to finish.\n&quot;</span>;<br>  <span class="hljs-comment">// 主线程什么都没做，但是由于调用了 t1.join()，需要等待 t1 线程完成任务</span><br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;done.\n&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以一次创建多个线程，用一个 vector保存，注意下面 std::mem_fn 的作用是将一个类的成员函数包装成一个参数为对象的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                                                                                                                                                                         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>  &#125;;<br>  std::vector&lt;std::thread&gt; thread_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(thread_func));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;wait for all the worker thread to finish.\n&quot;</span>;<br>  std::for_each(thread_list.<span class="hljs-built_in">begin</span>(), thread_list.<span class="hljs-built_in">end</span>(),<br>                std::<span class="hljs-built_in">mem_fn</span>(&amp;std::thread::join));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>detach 的作用是创建分离线程&#x2F;后台线程&#x2F;守护线程：</p><blockquote><p>Detached threads are also called daemon &#x2F; Background threads.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>t1.<span class="hljs-built_in">detach</span>();  <span class="hljs-comment">// After calling detach(), std::thread object</span><br>              <span class="hljs-comment">// is no longer associated with the actual thread of execution.</span><br></code></pre></td></tr></table></figure><ul><li>join是阻塞当前线程，并等待 thread object 对应的线程结束，当前线程继续执行</li><li>detach 是将线程从当前线程分离出去，即不受阻塞，操作系统会将其独立对待</li></ul><p>使用 <code>detach()</code> 函数会让线程在后台运行，即说明 主线程不会等待子线程运行结束才结束 。</p><p>通常称分离线程为守护线程(daemon threads), UNIX中守护线程是指，没有任何显式的用户接口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));                     <br>    &#125;<br>  &#125;;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func)</span></span>;<br>  t1.<span class="hljs-built_in">detach</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// main thread finished.</span><br><span class="hljs-comment">// thread id: 140529165158144</span><br><span class="hljs-comment">// 可以看到主线程没有等待 t1 线程完成就结束了</span><br></code></pre></td></tr></table></figure><p>要注意，一旦调用 join() 或者 detach()，那么线程对象就不再与实际线程有关联了，要避免重复调用 join() &#x2F; detach() 。</p><p>可以用 joinable() 判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br><span class="hljs-keyword">if</span>(t1.<span class="hljs-built_in">joinable</span>()) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Detaching Thread.&quot;</span> &lt;&lt; std::endl;<br>  t1.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;<br><span class="hljs-keyword">if</span>(t2.<span class="hljs-built_in">joinable</span>()) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Joining Thread.&quot;</span> &lt;&lt; std::endl;<br>  t2.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一点要注意，不要忘记调用线程对象的 join() &#x2F; detach() 而直接 return:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    &#125;<br>  &#125;;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func)</span></span>;<br>  <span class="hljs-comment">// Program will terminate as we have&#x27;t called either join or detach with the std::thread object.</span><br>  <span class="hljs-comment">// Hence std::thread&#x27;s object destructor will terminate the program</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 RAII(Resource Acquisition Is Initialization) 对 thread 进行封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadRAII</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ThreadRAII</span>(std::thread &amp;t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br>  ~<span class="hljs-built_in">ThreadRAII</span>() &#123;<br>    <span class="hljs-keyword">if</span> (t_.<span class="hljs-built_in">joinable</span>()) &#123;<br>      t_.<span class="hljs-built_in">detach</span>();<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::thread&amp; t_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  <span class="hljs-function">ThreadRAII <span class="hljs-title">wrapper_t</span><span class="hljs-params">(t)</span></span>;  <span class="hljs-comment">// If we comment this Line, then program will crash</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传递参数给线程"><a href="#传递参数给线程" class="headerlink" title="传递参数给线程"></a>传递参数给线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> std::string &amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>  std::string str = <span class="hljs-string">&quot;hello, world&quot;</span>;<br><br>  <span class="hljs-comment">// directly pass params to std::thread&#x27;s constructor</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, x, str)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，小心传递局部变量或者动态内存的地址和指针，不同线程难以保证指针是否有效。对于真正要共享的内容，要记得 加锁 。</p><h3 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h3><p>默认传参给线程会拷贝一份参数的值到线程，即使声明了引用参数也无法改变外部变量，如何传递引用？可以用 <code>std::ref()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> &amp;y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(x);  <span class="hljs-comment">// 强制转换为非 const</span><br>  ++y;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inside thread x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, before t1 starts, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, x)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, after t1 joins, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main thread, before t1 starts, x: 9</span><br><span class="hljs-comment">inside thread x: 10</span><br><span class="hljs-comment">main thread, after t1 joins, x: 9</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 可以看到，即使声明了引用参数，也没有改变 main thread 中 x 的值</span><br></code></pre></td></tr></table></figure><p>使用 <code>std::ref</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> &amp;y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(x);  <span class="hljs-comment">// 强制转换为非 const</span><br>  ++y;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inside thread x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, before t1 starts, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, std::ref(x))</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, after t1 joins, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main thread, before t1 starts, x: 9</span><br><span class="hljs-comment">inside thread x: 10</span><br><span class="hljs-comment">main thread, after t1 joins, x: 10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="传递成员函数"><a href="#传递成员函数" class="headerlink" title="传递成员函数"></a>传递成员函数</h3><p>成员函数传递给线程，注意第一个函数参数要传实例的地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  A a;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;A::say_hello, &amp;a, <span class="hljs-string">&quot;stranger&quot;</span>)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Lock-机制处理多线程数据共享"><a href="#使用-Lock-机制处理多线程数据共享" class="headerlink" title="使用 Lock 机制处理多线程数据共享"></a>使用 Lock 机制处理多线程数据共享</h2><h3 id="Race-condition"><a href="#Race-condition" class="headerlink" title="Race condition"></a>Race condition</h3><blockquote><p>Race condition is a kind of a bug that occurs in multithreaded applications.  </p></blockquote><p>多个线程并发地访问同一个地址时，如果不做一些特殊处理，可能会引发意想不到的结果。</p><h3 id="Lock-机制"><a href="#Lock-机制" class="headerlink" title="Lock 机制"></a>Lock 机制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Count</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 多线程写操作，要加锁</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    mutex_for_x_.<span class="hljs-built_in">lock</span>();<br>    ++x_;<br>    mutex_for_x_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">()</span> </span>&#123;<br>    mutex_for_x_.<span class="hljs-built_in">lock</span>();<br>    --x_;<br>    mutex_for_x_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x_;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x_ = <span class="hljs-number">0</span>;<br>  std::mutex mutex_for_x_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Count count;<br>  std::vector&lt;std::thread&gt; thread_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>      thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Count::add, &amp;count));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Count::reduce, &amp;count));<br>    &#125;<br>  &#125;<br>  std::for_each(thread_list.<span class="hljs-built_in">begin</span>(), thread_list.<span class="hljs-built_in">end</span>(),<br>      std::<span class="hljs-built_in">mem_fn</span>(&amp;std::thread::join));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;final count: &quot;</span> &lt;&lt; count.<span class="hljs-built_in">get_count</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用 std::lock_guard，实现了对 mutex 对象的 RAII：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// lock_guard 对象出作用域会自动 unlock mutex</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_for_x_)</span></span>;<br>    ++x_;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Condition-variable-处理事件响应"><a href="#使用-Condition-variable-处理事件响应" class="headerlink" title="使用 Condition variable 处理事件响应"></a>使用 Condition variable 处理事件响应</h2><p>假设要实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程从队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。</p><p>mutex 可以完成这个任务，但是却存在着性能问题。消费者每次都要等待锁释放。如果生产者处理开销较大，那么会有不必要的等待开销。</p><p>更合适的模型是，生产者往队列中添加完数据后，立刻通知消费者干活，如何实现这种“通知”的机制？C++11 提供了 Condition variable 来帮我们实现多线程之间的 signal 机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Application</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">Application</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_data</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;loading data...\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    <span class="hljs-comment">// lock the data</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    data_loaded_ = <span class="hljs-literal">true</span>;<br>    cond_var_.<span class="hljs-built_in">notify_one</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main_proc</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main processing...\n&quot;</span>;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-comment">// Start waiting for the Condition Variable to get signaled</span><br>    <span class="hljs-comment">// wait() will internally release the lock and make the thread to block</span><br>    <span class="hljs-comment">// as soon as condition variable get signaled, resume the thread and</span><br>    <span class="hljs-comment">// again acquire the lock. Then check if condition is met or not</span><br>    <span class="hljs-comment">// if condition is met then continue else again go in wait.</span><br>    cond_var_.<span class="hljs-built_in">wait</span>(lock, [&amp;]() &#123;<br>      <span class="hljs-keyword">return</span> data_loaded_;<br>    &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main processing done.\n&quot;</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">bool</span> data_loaded_ = <span class="hljs-literal">false</span>;<br>  std::mutex mutex_;<br>  std::condition_variable cond_var_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Application app;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;Application::load_data, &amp;app)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(&amp;Application::main_proc, &amp;app)</span></span>;<br>  t2.<span class="hljs-built_in">join</span>();<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>cond_var_.wait()</code> 要和 <code>std::unique_lock</code> 配合使用，不能用 <code>std::lock_guard</code>，因为 <code>wait()</code> 函数会先调用互斥锁的 <code>unlock()</code> 函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而 <code>lock_guard</code> 没有 <code>lock</code> 和 <code>unlock</code> 接口，而 <code>unique_lock</code> 提供了。这就是必须使用 <code>unique_lock</code> 的原因。</p><p>关于 std::condition_variable 的成员函数：</p><blockquote><ul><li>wait()：It makes the current thread to block until the condition variable get signaled or a spurious wake up happens.</li><li>notify_one()：If any threads are waiting on same conditional variable object then notify_one unblocks one of the waiting threads.</li><li>notify_all()：If any threads are waiting on same conditional variable object then notify_all unblocks all of the waiting threads.</li></ul></blockquote><p>再看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>std::mutex mu;<br>std::condition_variable cond;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>    q.<span class="hljs-built_in">push_front</span>(count);<br>    locker.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 注意控制锁的粒度，q.push_front() 之后就不需要保护了，可以提前 unlock</span><br>    cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// Notify one waiting thread, if there is one.</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    --count;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( data != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">empty</span>()) &#123;<br>      cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// Unlock mutex and wait to be notified</span><br>    &#125;<br>    data = q.<span class="hljs-built_in">back</span>();<br>    q.<span class="hljs-built_in">pop_back</span>();<br>    locker.<span class="hljs-built_in">unlock</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(function_1)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(function_2)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-std-future-和-std-promise-处理线程的返回值"><a href="#使用-std-future-和-std-promise-处理线程的返回值" class="headerlink" title="使用 std::future 和 std::promise 处理线程的返回值"></a>使用 std::future 和 std::promise 处理线程的返回值</h2><p>假设我们要写一个程序，从主线程创建一个线程来压缩一个文件夹，压缩完成后在主线程打印压缩文件名和大小，要求压缩线程返回压缩文件名和文件大小。</p><p>第一种方式：通过共享指针实现，向压缩线程传入一个指针变量，利用 mutex，condition variable 完成。</p><p>第二种方式：使用 std::future 和 std::promise。</p><blockquote><ul><li>std::future is a class template and its object stores the future value .</li><li>std::promise is also a class template and its object promises to set the value in future . Each std::promise object has an associated std::future object that will give the value once set by the std::promise object.</li><li>A std::promise object shares data with its associated std::future object.</li></ul></blockquote><p>如图所示：</p><img src="/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/cxx11_promise_future.png" class="" title="cxx11_promise_future"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; * promise_obj)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Inside Thread&quot;</span> &lt;&lt; std::endl;<br>  promise_obj-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-number">42</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  std::promise&lt;<span class="hljs-type">int</span>&gt; promise_obj;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; future_obj = promise_obj.<span class="hljs-built_in">get_future</span>();<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(init, &amp;promise_obj)</span></span>;<br>  std::cout &lt;&lt; future_obj.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// blocked on the std::future::get() function</span><br>  t.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-11-异步调用"><a href="#C-11-异步调用" class="headerlink" title="C++11 异步调用"></a>C++11 异步调用</h2><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h3><p>异步操作的主要目的是 让调用方法的主线程不需要同步等待调用函数，从而可以让主线程继续执行它下面的代码 。因此异步操作无须额外的线程负担，使用回调的方式进行处理。在设计良好的情况下，处理函数可以不必或者减少使用共享变量，减少了死锁的可能。当需要执行I&#x2F;O操作时，使用异步操作比使用线程+同步I&#x2F;O操作更合适。</p><p>异步和多线程并不是一个同等关系， 异步是目的，多线程是实现异步的一个手段 。实现异步可以采用多线程或交给另外的进程来处理。</p><ul><li>std::future 可以从异步任务中获取结果，一般与 std::async 配合使用， std::async 用于创建异步任务，实际上就是创建一个线程执行相应任务。</li><li>std::async 就是异步编程的高级封装，封装了 std::future 的操作，基本上可以代替 std::thread 的所有事情</li><li>std::async 的操作，其实相当于封装了 std::promise 、 std::packaged_task 加上 std::thread 。<blockquote><p>std::async： std::async() is a function template that accepts a callback(i.e. function or function object) as an argument and potentially executes them asynchronously.</p></blockquote></li></ul><p>std::async 的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>future&lt;<span class="hljs-keyword">typename</span> result_of&lt;<span class="hljs-built_in">Fn</span>(Args...)&gt;::type&gt; <span class="hljs-built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><blockquote><p>std::async returns a std::future<T>, that stores the value returned by function object executed by std::async(). Arguments expected by function can be passed to std::async() as arguments after the function pointer argument.<br>First argument in std::async is launch policy, it control the asynchronous behaviour of std::async .</p></blockquote><ul><li>std::launch::async ，调用即创建线程，在另一个 thread 中执行任务</li><li>std::launch::deferred ，延迟加载方式创建线程，调用时不创建线程，直到调用 future 的 get 或者 wait 时才创建线程(lazy evaluation)</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_data_from_db</span><span class="hljs-params">(std::string recvd_data)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvd_data;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_data_from_file</span><span class="hljs-params">(std::string recvd_data)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvd_data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  system_clock::time_point start = system_clock::<span class="hljs-built_in">now</span>();<br><br>  <span class="hljs-comment">// 异步调用，std::launch::async 策略，会立即创建一个线程工作</span><br>  <span class="hljs-comment">// 如果改成 std::launch::deferred，那么这个例子就看不到使用异步加速的效果了</span><br>  std::future&lt;std::string&gt; result_from_db =<br>      std::<span class="hljs-built_in">async</span>(std::launch::async, fetch_data_from_db, <span class="hljs-string">&quot;Data&quot;</span>);<br><br>  <span class="hljs-comment">// Fetch Data from File</span><br>  std::string file_data = <span class="hljs-built_in">fetch_data_from_file</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><br>  <span class="hljs-comment">// Fetch Data from DB</span><br>  <span class="hljs-comment">// Will block till data is available in future&lt;std::string&gt; object.</span><br>  std::string db_data = result_from_db.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">auto</span> end = system_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-keyword">auto</span> diff = duration_cast &lt; std::chrono::seconds &gt; (end - start).<span class="hljs-built_in">count</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time Taken = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot; Seconds&quot;</span> &lt;&lt; std::endl;<br>  std::string data = db_data + <span class="hljs-string">&quot; :: &quot;</span> + file_data;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::promise 通过 set_value 可以使得与之关联的 std::future 获取数据。 std::packaged_task 则更为强大，它允许传入一个函数，并将函数计算的结果传递给 std::future。</p><p>std::packaged_task&lt;&gt; is a class template and represents a asynchronous task. It encapsulates:</p><ul><li>A callable entity i.e either function, lambda function or function object.</li><li>A shared state that stores the value returned or thrown exception by associated callback.</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(sum)</span></span>;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; future = task.<span class="hljs-built_in">get_future</span>();<br><br>  <span class="hljs-comment">// std::promise 一样，std::packaged_task 支持 move，但不支持拷贝</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(std::move(task), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-comment">// 等待异步计算结果</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 =&gt; &quot;</span> &lt;&lt; future.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>  t.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-std-future-和-std-promise-实现终止线程功能"><a href="#使用-std-future-和-std-promise-实现终止线程功能" class="headerlink" title="使用 std::future 和 std::promise 实现终止线程功能"></a>使用 std::future 和 std::promise 实现终止线程功能</h2><p>我们希望能显式控制一个进程的终止，该如何实现？前面提到过了 std::promise 和 std::future，只有当 promise 设置值的时候 future 才会真正获取值，那么可以把 promise::set_value 作为一个通知信号来使用，，检查 future 的状态就知道是不是要结束线程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">void</span>&gt; future_obj)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread Start&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 利用 std::future::wait_for() 来控制循环是否终止</span><br>  <span class="hljs-comment">// 如果相应的 promise object 调用了 set_value()，那么结束循环</span><br>  <span class="hljs-keyword">while</span> (future_obj.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">0</span>)) ==<br>      std::future_status::timeout) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Doing Some Work&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread End&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Create a std::promise object</span><br>  std::promise&lt;<span class="hljs-type">void</span>&gt; exit_signal;<br><br>  <span class="hljs-comment">// Fetch std::future object associated with promise</span><br>  std::future&lt;<span class="hljs-type">void</span>&gt; future_obj = exit_signal.<span class="hljs-built_in">get_future</span>();<br><br>  <span class="hljs-comment">// Starting Thread &amp; move the future object in lambda function by reference</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;thread_callback, std::move(future_obj))</span></span>;<br><br>  <span class="hljs-comment">// Wait for 10 sec</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Asking Thread to Stop&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// Set the value in promise</span><br>  exit_signal.<span class="hljs-built_in">set_value</span>();<br><br>  <span class="hljs-comment">// Wait for thread to join</span><br>  t.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting Main Function&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用面向对象封装一个 Stoppable 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stoppable</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Stoppable</span>() : <span class="hljs-built_in">future_obj_</span>(exit_signal_.<span class="hljs-built_in">get_future</span>()) &#123;&#125;<br>  <span class="hljs-built_in">Stoppable</span>(Stoppable &amp;&amp;obj) : <span class="hljs-built_in">exit_signal_</span>(std::<span class="hljs-built_in">move</span>(obj.exit_signal_)),<br>      <span class="hljs-built_in">future_obj_</span>(std::<span class="hljs-built_in">move</span>(obj.future_obj_)) &#123;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stoppable</span>() = <span class="hljs-keyword">default</span>;<br><br>  Stoppable&amp; <span class="hljs-keyword">operator</span>=(Stoppable &amp;&amp;obj) &#123;<br>    exit_signal_ = std::<span class="hljs-built_in">move</span>(obj.exit_signal_);<br>    future_obj_ = std::<span class="hljs-built_in">move</span>(obj.future_obj_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">run</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_stop_requested</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (future_obj_.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">0</span>)) ==<br>        std::future_status::timeout) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    exit_signal_.<span class="hljs-built_in">set_value</span>();<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::promise&lt;<span class="hljs-type">void</span>&gt; exit_signal_;<br>  std::future&lt;<span class="hljs-type">void</span>&gt; future_obj_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> : <span class="hljs-keyword">public</span> Stoppable &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task Start&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">is_stop_requested</span>()) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Doing Some Work&quot;</span> &lt;&lt; std::endl;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task End&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  MyTask task;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    task.run();</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Asking Task to Stop&quot;</span> &lt;&lt; std::endl;<br>  task.<span class="hljs-built_in">stop</span>();<br>  t.<span class="hljs-built_in">join</span>();<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread Joined&quot;</span> &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting Main Function&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<img src="/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/mario.jpeg" class="" title="mario">]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mario</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
