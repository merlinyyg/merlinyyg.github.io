<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>bind</title>
    <link href="/2024/01/04/bind/"/>
    <url>/2024/01/04/bind/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14575979.html">https://www.cnblogs.com/linuxAndMcu/p/14575979.html</a></p></blockquote><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><h2 id="C-11为什么要引入std-bind？"><a href="#C-11为什么要引入std-bind？" class="headerlink" title="C++11为什么要引入std::bind？"></a>C++11为什么要引入std::bind？</h2><p>C++11 引入了<code>std::bind</code>，顾名思义，是用来绑定函数调用的某些参数的。<code>std::bind</code>能改造现有函数，生成新的函数。举例说明，现在有这么个函数声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>我现在需求，我要一个有 2 个 <code>int</code> 类型参数的函数，并且第2个参数默认为 <code>2</code>。你可千万不要屁颠屁颠的在去写一个<code>f(int i, int i = 2)</code>，这里<code>std::bind</code>的作用体现出来了，看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">bind</span>(&amp;f, std::placeholders::_1, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>好了，<code>std::bind</code>之后的返回值，那就可以拜托给我们的<code>std::funtion</code>同学了，我们定义个函数类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; fun = std::<span class="hljs-built_in">bind</span>(&amp;f, std::placeholders::_1, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>把<code>std::bind</code>的返回值给 <code>fun</code>，于是我们就生成了一个 <code>b</code> 强制为 <code>2</code>，只有 <code>1</code> 个<code>int a</code>参数的 <code>fun</code> 新函数。</p><p>最后要说一句，<code>std::bind</code>返回后的函数和原函数是 <code>2</code> 个完全不同的函数，这个你可以通过打印他们的内存地址看出来，这个就交给各位看官自己去实现了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>std::bind</code>函数定义在头文件<code>&lt;functional&gt;</code>中，是一个函数模板，它就像一个函数适配器，接受一个可调用对象<code>（callable object）</code>，生成一个新的可调用对象来“适应”原对象的参数列表。</p><p>使用<code>std::bind</code>可以将可调用对象和参数一起绑定，绑定后的结果使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候，所以经常用来实现回调函数。</p><p><code>std::bind</code>通常有两大作用：</p><ul><li>将可调用对象与参数一起绑定为另一个<code>std::function</code>供调用</li><li>将<code>n</code> 元可调用对象转成 <code>m(m &lt; n)</code> 元可调用对象，绑定一部分参数，这里需要使用<code>std::placeholders</code></li></ul><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p><code>std::bind</code>函数有两种函数原型，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-comment">/* unspecified */</span> <span class="hljs-built_in">bind</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ret</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-comment">/* unspecified */</span> <span class="hljs-built_in">bind</span> (Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><h3 id="函数模板说明"><a href="#函数模板说明" class="headerlink" title="函数模板说明"></a>函数模板说明</h3><ul><li>基于参数<code>fn</code>返回一个函数对象，并且以<code>args</code>参数绑定为函数对象的参数。</li><li>每个参数要么绑定一个参数值，要么绑定为一个<code>std::placeholders</code>（占位符，如 <code>_1</code>,<code> _2</code>, <code>...</code>, <code>_n</code>）。</li><li>如果参数绑定成一个值，那么返回的函数对象将总使用绑定的参数值做为调用参数，即调用传入参数将不起作用；如果参数绑定为<code>std::placeholders</code>，那么返回的函数对象在被调用时需要传入实时参数，参数填充的位置即由<code>placeholder</code>指定的序号。</li></ul><h3 id="函数模板参数说明"><a href="#函数模板参数说明" class="headerlink" title="函数模板参数说明"></a>函数模板参数说明</h3><ul><li><code>fn</code>：可调用的函数对象，比如函数对象、函数指针、函数引用、成员函数或者数据成员函数。</li><li><code>args</code>：需要绑定的函数的参数列表，使用命名空间占位符<code>std::placeholders::_1</code>，<code>std::placeholders::_2</code>标志参数，其中<code>std::placeholders::_1</code>标志为参数列表中的第一个参数，<code>std::placeholders::_2</code>标志参数列表中的第二个参数，<code>std::placeholders::_3</code>标志参数列表中的第三个参数，以此类推。</li></ul><h3 id="函数模板返回值说明"><a href="#函数模板返回值说明" class="headerlink" title="函数模板返回值说明"></a>函数模板返回值说明</h3><p>返回一个函数对象，该函数在调用时使用参数列表<code>args</code>来调用<code>fn</code>。如果<code>fn</code>是指向类的成员函数，则返回函数第一个参数应该是该类的成员、或者成员对象的引用、或者是成员对象的指针。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-keyword">auto</span> lamdaExps = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 1.类成员函数</span><br><span class="hljs-comment">// 2.类静态成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">classMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">staticMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 绑定普通函数(使用占位符先占位，然后执行时再传参)</span><br><span class="hljs-keyword">auto</span> bindFun = std::<span class="hljs-built_in">bind</span>(&amp;testFun, std::placeholders::_1, std::placeholders::_2);<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">bindFun</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数_1：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><span class="hljs-comment">// 绑定普通函数(也可以只使用一个占位符来占位，指定一个参数)</span><br><span class="hljs-keyword">auto</span> bindFun2 = std::<span class="hljs-built_in">bind</span>(&amp;testFun, std::placeholders::_1, <span class="hljs-number">8</span>);<br>ret = <span class="hljs-built_in">bindFun2</span>(<span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数_2：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 绑定Lambda表达式</span><br><span class="hljs-keyword">auto</span> bindFun3 = std::<span class="hljs-built_in">bind</span>(lamdaExps, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Lambda表达式：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 绑定仿函数</span><br>Functor testFunctor;<br><span class="hljs-keyword">auto</span> bindFun4 = std::<span class="hljs-built_in">bind</span>(testFunctor, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun3</span>(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;仿函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 绑定类成员函数</span><br>TestClass testObj;<br><span class="hljs-keyword">auto</span> bindFun5 = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun5</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><span class="hljs-comment">// 绑定类静态成员函数</span><br><span class="hljs-keyword">auto</span> bindFun6 = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::staticMemberFun, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">bindFun6</span>(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类静态成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">普通函数_1：<span class="hljs-number">15</span><br>普通函数_2：<span class="hljs-number">18</span><br>Lambda表达式：<span class="hljs-number">30</span><br>仿函数：<span class="hljs-number">40</span><br>类成员函数：<span class="hljs-number">50</span><br>类静态成员函数：<span class="hljs-number">60</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>function</title>
    <link href="/2024/01/03/function/"/>
    <url>/2024/01/03/function/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载:<a href="https://www.cnblogs.com/linuxAndMcu/p/14575971.html">https://www.cnblogs.com/linuxAndMcu/p/14575971.html</a></p></blockquote><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="C-11为什么要引入std-function？"><a href="#C-11为什么要引入std-function？" class="headerlink" title="C++11为什么要引入std::function？"></a>C++11为什么要引入std::function？</h2><p>在 C++03 的时代，是使用函数指针来把一个函数作为参数传递，这样我们就可以实现回调函数的机制。程序设计，特别是程序库设计时，经常需要涉及到回调，如果针对每种不同的可调用对象单独进行声明类型，代码将会非常散乱，也不灵活。</p><p>所以 C++11 就引入了<code>std::function</code>类模板，这是一种通用、多态的函数封装，在头文件<code>&lt;functional&gt;</code>定义。<code>std::function</code>的实例可以对任何可以调用的目标对象进行存储、复制和调用操作。而函数指针只能指向一种类型的函数，并且函数指针也是类型不安全的。</p><p>可调用对象<code>（callable object）</code>包括：</p><ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>bind 创建的对象</li><li>重载了函数调用运算符的类（仿函数）</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对<code>std::function</code>最简单的理解就是：<code>std::function</code>实现了函数的存储，即先将可调用实体保存起来，在需要的时候再调用。</p><p>关于可调用对象转换为<code>std::function</code>对象需要遵守以下两条原则：</p><ul><li>转换后的<code>std::function</code>对象的参数能转换为可调用对象的参数；</li><li>可调用对象的返回值能转换为<code>std::function</code>对象的返回值。<br><code>std::function</code>可以绑定全局函数，静态函数，但是绑定类的成员函数时，必须要借助<code>std::bind</code>的帮忙。</li></ul><p>使用者需要注意，它不能被用来检查相等或者不相等，但是可以与 <code>NULL</code> 或者 <code>nullptr</code> 进行比较。</p><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span>... Args &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">function</span>&lt;<span class="hljs-built_in">R</span>(Args...)&gt;<br></code></pre></td></tr></table></figure><ul><li><code>R</code> 是返回值类型。</li><li><code>Args</code> 是函数的参数类型。<br>定义一个<code>std::function</code>对象很简单，就是将可调用对象的返回值类型和参数类型作为模板参数传递给<code>std::function</code>模板类。比如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::function&lt;函数类型&gt;</span><br>std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; functional1;<br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; functional2;<br></code></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>std::function</code>的使用有多态和万总归一的感觉，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">testFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// Lambda表达式</span><br><span class="hljs-keyword">auto</span> lamdaExps = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 仿函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 1.类成员函数</span><br><span class="hljs-comment">// 2.类静态成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">classMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">staticMemberFun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 普通函数</span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; functional = testFun;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 普通函数指针</span><br>functional = &amp;testFun;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span> ,<span class="hljs-number">20</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;普通函数指针：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// Lambda表达式</span><br>functional = lamdaExps;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Lambda表达式：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 仿函数</span><br>Functor testFunctor;<br>functional = testFunctor;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">40</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;仿函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 类成员函数（使用std::bind绑定类成员函数）</span><br>TestClass testObj;<br>functional = std::<span class="hljs-built_in">bind</span>(&amp;TestClass::classMemberFun, testObj, std::placeholders::_1, std::placeholders::_2);<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">50</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><span class="hljs-comment">// 类静态成员函数</span><br>functional = TestClass::staticMemberFun;<br>ret = <span class="hljs-built_in">functional</span>(<span class="hljs-number">10</span>, <span class="hljs-number">60</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;类静态成员函数：&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可见<code>std::function</code>的使用其实是很简单的，只要创建一个函数或者类对象，并传入相应的参数就可以存储任何具有相同返回值和参数的可调用对象，在调用的时候直接将<code>std::function</code>对象加上 <code>()</code> 或加上相应参数就可以调用存储在其中的可调用实体。结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">普通函数：<span class="hljs-number">20</span><br>普通函数指针：<span class="hljs-number">30</span><br>Lambda表达式：<span class="hljs-number">40</span><br>仿函数：<span class="hljs-number">50</span><br>类成员函数：<span class="hljs-number">60</span><br>类静态成员函数：<span class="hljs-number">70</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>weak_ptr和unique_ptr</title>
    <link href="/2024/01/02/weak-ptr%E5%92%8Cunique-ptr/"/>
    <url>/2024/01/02/weak-ptr%E5%92%8Cunique-ptr/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576078.html">https://www.cnblogs.com/linuxAndMcu/p/14576078.html</a></p></blockquote><h1 id="weak-ptr和unique-ptr"><a href="#weak-ptr和unique-ptr" class="headerlink" title="weak_ptr和unique_ptr"></a>weak_ptr和unique_ptr</h1><h2 id="weak-ptr弱引用的智能指针"><a href="#weak-ptr弱引用的智能指针" class="headerlink" title="weak_ptr弱引用的智能指针"></a>weak_ptr弱引用的智能指针</h2><h3 id="shared-ptr相互引用会有什么后果？"><a href="#shared-ptr相互引用会有什么后果？" class="headerlink" title="shared_ptr相互引用会有什么后果？"></a>shared_ptr相互引用会有什么后果？</h3><p><code>shared_ptr</code>的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏。看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;  <span class="hljs-comment">// Parent类的前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::shared_ptr&lt;Parent&gt; father;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello Parent&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::shared_ptr&lt;Child&gt; son;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Parent&gt; <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;  <span class="hljs-comment">// 1  资源A</span><br>    <span class="hljs-function">std::shared_ptr&lt;Child&gt; <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;  <span class="hljs-comment">// 2   资源B</span><br>    parent-&gt;son = child;     <span class="hljs-comment">// 3   child.use_count() == 2 and parent.use_count() == 1 </span><br>    child-&gt;father = parent;  <span class="hljs-comment">// 4   child.use_count() == 2 and parent.use_count() == 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">hello Parent</span><br><span class="hljs-comment">hello child</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>很惊讶的发现，用了<code>shared_ptr</code>管理资源，没有调用 <code>Parent</code>和 <code>Child</code> 的析构函数，表示资源最后还是没有释放！内存泄漏还是发生了。</p><p>分析：</p><ul><li>执行编号<code>1</code>的语句时，构造了一个共享智能指针<code>p</code>，称呼它管理的资源叫做资源<code>A（new Parent()</code>产生的对象）吧， 语句<code>2</code>构造了一个共享智能指针<code>c</code>，管理资源<code>B(new Child()</code>产生的对象)，此时资源<code>A</code>和<code>B</code>的引用计数都是<code>1</code>，因为只有<code>1</code>个智能指针管理它们，执行到了语句<code>3</code>的时候，是一个智能指针的赋值操作，资源<code>B</code>的引用计数变为了<code>2</code>，同理，执行完语句<code>4</code>，资源<code>A</code>的引用计数也变成了<code>2</code>。</li><li>出了函数作用域时，由于析构和构造的顺序是相反的，会先析构共享智能指针<code>c</code>，资源<code>B</code>的引用计数就变成了<code>1</code>；接下来继续析构共享智能指针<code>p</code>，资源<code>A</code>的引用计数也变成了<code>1</code>。由于资源<code>A</code>和<code>B</code>的引用计数都不为<code>1</code>，说明还有共享智能指针在使用着它们，所以不会调用资源的析构函数！</li><li>这种情况就是个死循环，如果资源<code>A</code>的引用计数想变成<code>0</code>，则必须资源<code>B</code>先析构掉（从而析构掉内部管理资源<code>A</code>的共享智能指针），资源<code>B</code>的引用计数想变为<code>0</code>，又得依赖资源<code>A</code>的析构，这样就陷入了一个死循环。</li></ul><h3 id="weak-ptr如何解决相互引用的问题"><a href="#weak-ptr如何解决相互引用的问题" class="headerlink" title="weak_ptr如何解决相互引用的问题"></a>weak_ptr如何解决相互引用的问题</h3><p>要想解决上面循环引用的问题，只能引入新的智能指针<code>std::weak_ptr</code>。<code>std::weak_ptr</code>有什么特点呢？与<code>std::shared_ptr</code>最大的差别是在赋值的时候，不会引起智能指针计数增加。</p><ul><li><p><code>weak_ptr</code>被设计为与<code>shared_ptr</code>共同工作，可以从一个<code>shared_ptr</code>或者另一个<code>weak_ptr</code>对象构造，获得资源的观测权。但<code>weak_ptr</code>没有共享资源，它的构造不会引起指针引用计数的增加。</p></li><li><p>同样，在<code>weak_ptr</code>析构时也不会导致引用计数的减少，它只是一个静静地观察者。<code>weak_ptr</code>没有重载<code>operator*</code>和<code>-&gt;</code>，这是特意的，因为它不共享指针，不能操作资源，这是它弱的原因。</p></li><li><p>如要操作资源，则必须使用一个非常重要的成员函数<code>lock()</code>从被观测的<code>shared_ptr</code>获得一个可用的<code>shared_ptr</code>对象，从而操作资源。<br>当我们创建一个<code>weak_ptr</code>时，要用一个<code>shared_ptr</code>来初始化它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">// wp弱共享p; p的引用计数未改变</span><br></code></pre></td></tr></table></figure><p>我们在上面的代码基础上使用<code>std::weak_ptr</code>进行修改，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>;  <span class="hljs-comment">// Parent类的前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello child&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Child</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye child&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    <span class="hljs-comment">// 测试函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;testWork()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    std::weak_ptr&lt;Parent&gt; father;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello Parent&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Parent</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bye parent&quot;</span> &lt;&lt; std::endl; &#125;<br><br>    std::weak_ptr&lt;Child&gt; son;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testParentAndChild</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Parent&gt; <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Parent())</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Child&gt; <span class="hljs-title">child</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Child())</span></span>;<br>    parent-&gt;son = child;<br>    child-&gt;father = parent;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;parent_ref:&quot;</span> &lt;&lt; parent.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;child_ref:&quot;</span> &lt;&lt; child.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 把std::weak_ptr类型转换成std::shared_ptr类型，以调用内部成员函数</span><br>    std::shared_ptr&lt;Child&gt; tmp = parent.<span class="hljs-built_in">get</span>()-&gt;son.<span class="hljs-built_in">lock</span>();<br>    tmp-&gt;<span class="hljs-built_in">testWork</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;tmp_ref:&quot;</span> &lt;&lt; tmp.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">hello Parent</span><br><span class="hljs-comment">hello child</span><br><span class="hljs-comment">parent_ref:1</span><br><span class="hljs-comment">child_ref:1</span><br><span class="hljs-comment">testWork()</span><br><span class="hljs-comment">tmp_ref:2</span><br><span class="hljs-comment">bye child</span><br><span class="hljs-comment">bye parent</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>由以上代码运行结果我们可以看到：</p></li><li><p>所有的对象最后都能正常释放，不会存在上一个例子中的内存没有释放的问题;</p></li><li><p><code>parent</code> 和 <code>child</code> 在 <code>main</code> 函数中退出前，引用计数均为 <code>1</code>，也就是说，对<code>std::weak_ptr</code>的相互引用，不会导致计数的增加。</p></li></ul><h3 id="weak-ptr常用操作"><a href="#weak-ptr常用操作" class="headerlink" title="weak_ptr常用操作"></a>weak_ptr常用操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">weak_ptr&lt;T&gt; w;<span class="hljs-comment">// 空weak_ptr可以指向类型为T的对象</span><br><span class="hljs-function">weak_ptr&lt;T&gt; <span class="hljs-title">w</span><span class="hljs-params">(shared_ptr p)</span></span>;<span class="hljs-comment">// 与p指向相同对象的weak_ptr, T必须能转换为sp指向的类型</span><br>w = p;<span class="hljs-comment">// p可以是shared_ptr或者weak_ptr，赋值后w和p共享对象</span><br>w.<span class="hljs-built_in">reset</span>();<span class="hljs-comment">// weak_ptr置为空</span><br>w.<span class="hljs-built_in">use_count</span>();<span class="hljs-comment">// 与w共享对象的shared_ptr的计数</span><br>w.<span class="hljs-built_in">expired</span>();<span class="hljs-comment">// w.use_count()为0则返回true，否则返回false</span><br>w.<span class="hljs-built_in">lock</span>();<span class="hljs-comment">// w.expired()为true，返回空的shared_ptr;否则返回指向w的shared_ptr</span><br></code></pre></td></tr></table></figure><h2 id="unique-ptr独占的智能指针"><a href="#unique-ptr独占的智能指针" class="headerlink" title="unique_ptr独占的智能指针"></a>unique_ptr独占的智能指针</h2><h3 id="unique-ptr的基本使用"><a href="#unique-ptr的基本使用" class="headerlink" title="unique_ptr的基本使用"></a>unique_ptr的基本使用</h3><p><code>unique_ptr</code>相对于其他两个智能指针更加简单，它和<code>shared_ptr</code>使用差不多，但是功能更为单一，它是一个独占型的智能指针，不允许其他的智能指针共享其内部的指针，更像原生的指针（但更为安全，能够自己释放内存）。不允许赋值和拷贝操作，只能够移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">0</span>))</span></span>;<br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1; <span class="hljs-comment">// 错误，不能复制</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = std::<span class="hljs-built_in">move</span>(ptr1); <span class="hljs-comment">// 可以移动</span><br></code></pre></td></tr></table></figure><p>在 <code>C++11</code> 中，没有类似<code>std::make_shared</code>的初始化方法，但是在 <code>C++14</code> 中，对于<code>std::unique_ptr</code>引入了<code>std::make_unique</code>方法进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;std::string&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string(<span class="hljs-string">&quot;unique_ptr&quot;</span>))</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 is &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;<br><br>    std::unique_ptr&lt;std::string&gt; ptr2 = std::<span class="hljs-built_in">make_unique</span>&lt;std::string&gt;(<span class="hljs-string">&quot;make_unique init!&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ptr2 is &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">ptr1 is unique_ptr</span><br><span class="hljs-comment">ptr2 is make_unique init!</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h3 id="unique-ptr常用操作"><a href="#unique-ptr常用操作" class="headerlink" title="unique_ptr常用操作"></a>unique_ptr常用操作</h3><p>下面列出了unique_ptr特有的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;T&gt; u1 <span class="hljs-comment">// 空unique_ptr，可以指向类型为T的对象。u1会使用delete来释放它的指针</span><br>unique_ptr&lt;T, D&gt; u2 <span class="hljs-comment">// u2会使用一个类型为D的可调用对象来释放它的指针</span><br><span class="hljs-function">unique_ptr&lt;T, D&gt; <span class="hljs-title">u</span><span class="hljs-params">(d)</span> <span class="hljs-comment">// 空unique_ptr，指向类型为T的对象，用类型为D的对象d替代delete</span></span><br><span class="hljs-function">u </span>= <span class="hljs-literal">nullptr</span> <span class="hljs-comment">// 释放u指向的对象，将u置为空</span><br>u.<span class="hljs-built_in">release</span>() <span class="hljs-comment">// u放弃对指针的控制权，返回指针，并将u置为空</span><br>u.<span class="hljs-built_in">reset</span>() <span class="hljs-comment">// 释放u指向的对象</span><br>u.<span class="hljs-built_in">reset</span>(q) <span class="hljs-comment">// 如果提供了内置指针q，另u指向这个对象；否则将u置为空</span><br>u.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>)   <br><br></code></pre></td></tr></table></figure><p>虽然我们不能拷贝或赋值<code>unique_ptr</code>，但可以通过调用 <code>release</code> 或 <code>reset</code> 将指针的所有权从一个<code>（非const）unique_ptr</code>转移给另一个<code>unique_ptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Stegosaurus&quot;</span>))</span></span>;<br><span class="hljs-comment">// 将所有权从pl (指向string Stegosaurus)转移给p2 </span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1, release())</span></span>; <span class="hljs-comment">// release 将 p1 置为空 </span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br><br><span class="hljs-comment">// 将所有权从p3转移给p2</span><br>p2.<span class="hljs-built_in">reset</span>(p3.<span class="hljs-built_in">release</span>()); <span class="hljs-comment">// reset 释放了 p2 原来指向的内存</span><br><br></code></pre></td></tr></table></figure><p>调用 <code>release</code> 会切断<code>unique_ptr</code>和它原来管理的对象间的联系，如果我们不用另一个智能指针来保存 <code>release</code> 返回的指针，我们的程序就要负责资源的释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">p2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 错误：p2不会释放内存，而且我们丢失了指针</span><br><span class="hljs-keyword">auto</span> p = p2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 正确，但我们必须记得 delete(p)</span><br><span class="hljs-built_in">delete</span>(p);<br></code></pre></td></tr></table></figure><h3 id="传递unique-ptr参数和返回unique-ptr"><a href="#传递unique-ptr参数和返回unique-ptr" class="headerlink" title="传递unique_ptr参数和返回unique_ptr"></a>传递unique_ptr参数和返回unique_ptr</h3><p>**不能拷贝 <code>unique_ptr</code> 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 <code>unique_ptr</code>**。最常见的例子是从函数返回一个<code>unique_ptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span> <span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> (p))</span></span>;<br><span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于上面这段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，在《C++ Primer》13.6.2节（第473页）中有介绍。</p><h2 id="性能与安全的权衡"><a href="#性能与安全的权衡" class="headerlink" title="性能与安全的权衡"></a>性能与安全的权衡</h2><p>使用智能指针虽然能够解决内存泄漏问题，但是也付出了一定的代价。以<code>shared_ptr</code>举例：</p><ul><li><code>shared_ptr</code>的大小是原始指针的两倍，因为它的内部有一个原始指针指向资源，同时有个指针指向引用计数。<br>引用计数的内存必须动态分配。虽然一点可以使用<code>make_shared()</code>来避免，但也存在一些情况下不能够使用<code>make_shared()</code>。</li><li>增加和减小引用计数必须是原子操作，因为可能会有读写操作在不同的线程中同时发生。比如在一个线程里有一个指向一块资源的<code>shared_ptr</code>可能调用了析构（因此所指向的资源的引用计数减一），同时，在另一线程里，指向相同对象的一个<code>shared_ptr</code>可能执行了拷贝操作（因此，引用计数加一）。原子操作一般会比非原子操作慢。但是为了线程安全，又不得不这么做，这就给单线程使用环境带来了不必要的困扰。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shared_ptr共享的智能指针</title>
    <link href="/2024/01/02/shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/01/02/shared-ptr%E5%85%B1%E4%BA%AB%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14576049.html">https://www.cnblogs.com/linuxAndMcu/p/14576049.html</a></p></blockquote><h1 id="shared-ptr共享的智能指针"><a href="#shared-ptr共享的智能指针" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h1><p>C++ 程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。但使用普通指针，容易造成内存泄露（忘记释放）、二次释放、程序发生异常时内存泄露等问题等。所有 C++11 就引入了智能指针。</p><h2 id="原始指针容易发生内存泄漏"><a href="#原始指针容易发生内存泄漏" class="headerlink" title="原始指针容易发生内存泄漏"></a>原始指针容易发生内存泄漏</h2><p>C 语言中最常使用的是<code>malloc()</code>函数分配内存，<code>free()</code>函数释放内存，而 C++ 中对应的是<code>new</code>、<code>delete</code>关键字。<code>malloc()</code>只是分配了内存，而<code>new</code>则更进一步，不仅分配了内存，还调用了构造函数进行初始化。使用示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// malloc返回值是 void*</span><br>    <span class="hljs-type">int</span>* argC = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">free</span>(argC);<br><br>    <span class="hljs-type">char</span> *age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">25</span>); <span class="hljs-comment">// 做了两件事情 1.分配内存 2.初始化</span><br>    <span class="hljs-keyword">delete</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>new</code>和<code>delete</code>必须成对出现，有时候是不小心忘记了<code>delete</code>，有时候则是很难判断在这个地方自己是不是该<code>delete</code>，这个和资源的生命周期有关，这个资源是属于我这个类管理的还是由另外一个类管理的（其它类可能要使用），如果是别人管理的就由别人<code>delete</code>。</p><p>如果需要自己管理内存的话，最好显示的将自己的资源传递进去，这样的话，就能知道是该资源确实应该由自己来管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-type">char</span>* v, <span class="hljs-type">size_t</span> bufferSize)</span> </span>&#123;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面还是小问题，自己小心一点，再仔细看看文档，还是有机会避免这些情况的。但是在 C++ 引入异常的概念之后，程序的控制流就发生了根本性的改变，在写了 delete 的时候还是有可能发生内存泄漏。如下例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badThing</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 抛出一个异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1000</span>];<br><br>    <span class="hljs-built_in">badThing</span>();<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">delete</span>[] a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error happened &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>new</code>和<code>delete</code>是成对出现的，但是程序在中间的时候抛出了异常，由于没有立即捕获，程序从这里退出了，并没有执行到<code>delete</code>，内存泄漏还是发生了。</p><h2 id="使用构造函数和析构函数解决内存泄漏"><a href="#使用构造函数和析构函数解决内存泄漏" class="headerlink" title="使用构造函数和析构函数解决内存泄漏"></a>使用构造函数和析构函数解决内存泄漏</h2><p>C++ 中的构造函数和析构函数十分强大，可以使用构造和析构解决上面的内存泄漏问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeIntPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeIntPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : m_value(new int(v)) &#123;</span> &#125;<br>    ~<span class="hljs-built_in">SafeIntPointer</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_value;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~SafeIntPointer&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_value; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">badThing</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 抛出一个异常</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeIntPointer <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br>    <span class="hljs-built_in">badThing</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">test</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> i)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error happened &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// ~SafeIntPointer</span><br><span class="hljs-comment">// error happened 1</span><br><br></code></pre></td></tr></table></figure><p>可以看到，就算发生了异常，也能够保证析构函数成功执行！<strong>这里的例子是这个资源只有一个人使用，我不用了就将它释放掉。但还有种情况，一份资源被很多人共同使用，要等到所有人都不再使用的时候才能释放掉</strong>，对于这种问题，就需要对上面的<code>SafeIntPointer</code>增加一个引用计数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeIntPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SafeIntPointer</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> : m_value(new int(v)), m_used(new int(<span class="hljs-number">1</span>)) &#123;</span> &#125;<br>    ~<span class="hljs-built_in">SafeIntPointer</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~SafeIntPointer&quot;</span> &lt;&lt; endl;<br>        (*m_used) --; <span class="hljs-comment">// 引用计数减1</span><br>        <span class="hljs-keyword">if</span>(*m_used &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_used;<br>            <span class="hljs-keyword">delete</span> m_value;<br>            cout &lt;&lt; <span class="hljs-string">&quot;real delete resources&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">SafeIntPointer</span>(<span class="hljs-type">const</span> SafeIntPointer&amp; other) &#123;<br>        m_used = other.m_used;<br>        m_value = other.m_value;<br>        (*m_used)++; <span class="hljs-comment">// 引用计数加1</span><br>    &#125;<br>    SafeIntPointer&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> SafeIntPointer&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-comment">// 避免自我赋值!!</span><br>           <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        m_used = other.m_used;<br>        m_value = other.m_value;<br>        (*m_used)++; <span class="hljs-comment">// 引用计数加1</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> *m_value; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRefCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *m_used;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* m_used; <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">int</span>* m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">SafeIntPointer <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>    SafeIntPointer b = a;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>    SafeIntPointer c = b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ref count = &quot;</span> &lt;&lt; a.<span class="hljs-built_in">getRefCount</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">ref count = 1</span><br><span class="hljs-comment">ref count = 2</span><br><span class="hljs-comment">ref count = 3</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">~SafeIntPointer</span><br><span class="hljs-comment">real delete resources</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以看到每一次赋值，引用计数都加一，最后每次析构一次后引用计数减一，知道引用计数为 0，才真正释放资源。要写出一个正确的管理资源的包装类还是蛮难的，比如上面那个例子就不是线程安全的，只能属于一个玩具，在实际工程中简直没法用。</p><p>所以 C++11 中引入了智能指针（Smart Pointer），它利用了一种叫做 RAII（资源获取即初始化）的技术将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。这使得智能指针实质是一个对象，行为表现的却像一个指针。</p><p>智能指针主要分为<code>shared_ptr</code>、<code>unique_ptr</code>和<code>weak_ptr</code>三种，使用时需要引用头文件<code>&lt;memory&gt;</code>。C++98 中还有<code>auto_ptr</code>，基本被淘汰了，不推荐使用。而 C++11 中<code>shared_ptr</code>和<code>weak_ptr</code>都是参考boost库实现的。</p><h2 id="shared-ptr共享的智能指针-1"><a href="#shared-ptr共享的智能指针-1" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h2><h3 id="shared-ptr的初始化"><a href="#shared-ptr的初始化" class="headerlink" title="shared_ptr的初始化"></a>shared_ptr的初始化</h3><p>**最安全的分配和使用动态内存的方法是调用一个名为 <code>make_shared</code> 的标准库函数。 此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>**。与智能指针一样，<code>make_shared</code> 也定义在头文件 <code>memory</code> 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指向一个值为42的int的shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// p4 指向一个值为&quot;9999999999&quot;的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<br><br><span class="hljs-comment">// p5指向一个值初始化的int</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();<br></code></pre></td></tr></table></figure><p>我们还可以用 <code>new</code> 返回的指针来初始化智能指针，不过接受指针参数的智能指针构造函数是 <code>explicit</code> 的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (<span class="hljs-number">1024</span>); <span class="hljs-comment">// 错误：必须使用直接初始化形式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">1024</span>))</span></span>;<span class="hljs-comment">// 正确：使用了直接初始化形式</span><br></code></pre></td></tr></table></figure><p>出于相同的原因，一个返回 <code>shared_ptr</code> 的函数不能在其返回语句中隐式转换一个普通指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p); <span class="hljs-comment">// 错误：隐式转换为 shared_ptr&lt;int&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shared-ptr的基本使用"><a href="#shared-ptr的基本使用" class="headerlink" title="shared_ptr的基本使用"></a>shared_ptr的基本使用</h3><p><code>std::shared_ptr</code>的基本使用很简单，看几个例子就明白了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;Test&gt; p1 = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#123;<br>        std::shared_ptr&lt;Test&gt; p2 = p1;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;2 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;3 ref:&quot;</span> &lt;&lt; p1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Test</span>()<br><span class="hljs-number">1</span> ref:<span class="hljs-number">1</span><br><span class="hljs-number">2</span> ref:<span class="hljs-number">2</span><br><span class="hljs-number">3</span> ref:<span class="hljs-number">1</span><br>~<span class="hljs-built_in">Test</span>()<br></code></pre></td></tr></table></figure><p>针对代码解读如下：</p><ul><li><code>std::make_shared</code>里面调用了 <code>new</code> 操作符分配内存；</li><li>第二个<code>p1.use_count()</code>之所以显示为 <code>2</code>，是因为增加了引用对象 <code>p2</code>，而随着大括号的结束，<code>p2</code> 的作用域结束，所以 <code>p1</code> 的引用计数变回 <code>1</code>，而随着 <code>main</code> 函数的结束，<code>p1</code> 的作用域结束，此时检测到计数为 <code>1</code>，那就会在销毁 <code>p1</code> 的同时，调用 <code>p1</code> 的析构函数 <code>delete</code> 掉之前分配的内存空间；</li></ul><h3 id="shared-ptr常用操作"><a href="#shared-ptr常用操作" class="headerlink" title="shared_ptr常用操作"></a>shared_ptr常用操作</h3><p>下面列出了<code>shared_ptr</code>独有的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">make_shared</span>&lt;T&gt;(args) <span class="hljs-comment">// 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象</span><br><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">p</span><span class="hljs-params">(q)</span> <span class="hljs-comment">// p是shared_ptr q的拷贝；此操作会递增q中的引用计数。q中的指针必须能转换成T*</span></span><br><span class="hljs-function">p </span>= q <span class="hljs-comment">// p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p中的引用计数，递增q中的引用计数。若p中的引用计数变为0，则将其管理的原内存释放</span><br>p.<span class="hljs-built_in">unique</span>() <span class="hljs-comment">// 若p.use_count()为1，返回true；否则返回false</span><br>p.<span class="hljs-built_in">use_count</span>() <span class="hljs-comment">// 返回与p共享对象的智能指针数量；可能很慢，主要用于调试</span><br></code></pre></td></tr></table></figure><p>下面介绍一些改变<code>shared_ptr</code>的其他方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">p.<span class="hljs-built_in">reset</span> () <span class="hljs-comment">//若p是唯一指向其对象的shared_ptr，reset会释放此对象。</span><br>p.<span class="hljs-built_in">reset</span>(q) <span class="hljs-comment">//若传递了可选的参数内置指针q，会令P指向q，否则会将P置为空。</span><br>p.<span class="hljs-built_in">reset</span>(q, d) <span class="hljs-comment">//若还传递了参数d,将会调用d而不是delete 来释放q</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C++11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async执行异步任务</title>
    <link href="/2024/01/02/async%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <url>/2024/01/02/async%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.cnblogs.com/linuxAndMcu/p/14577285.html">https://www.cnblogs.com/linuxAndMcu/p/14577285.html</a></p></blockquote><h1 id="async执行异步任务"><a href="#async执行异步任务" class="headerlink" title="async执行异步任务"></a>async执行异步任务</h1><h2 id="std-aysnc介绍"><a href="#std-aysnc介绍" class="headerlink" title="std::aysnc介绍"></a>std::aysnc介绍</h2><p><code>std::async</code>用于创建异步任务，实际上就是创建一个线程异步执行相应任务，它接受回调（即函数或函数对象）作为参数。</p><p><code>std::async</code>就是异步编程的高级封装，相当于封装了<code>std::promise</code>、<code>std::packaged_task</code>加上<code>std::thread</code>，基本上可以代替<code>std::thread</code>的所有事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>future&lt;<span class="hljs-keyword">typename</span> result_of&lt;<span class="hljs-built_in">Fn</span>(Args...)&gt;::type&gt; <span class="hljs-built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><p><code>std::async</code>返回一个<code>std::future</code>，该值存储由<code>std::async</code>执行的函数对象返回的值。</p><p><code>std::async</code>中的第一个参数是启动策略，它控制<code>std::async</code>的异步行为。我们可以使用 3 种不同的启动策略来创建，即：</p><ul><li><code>std::launch::async</code>：它保证了异步行为，即传递的函数将在单独的线程中执行。</li><li><code>std::launch::deferred</code>：非异步行为，即当其他线程将来调用 get() 以访问共享状态时，将调用 Function。</li><li><code>std::launch::async | std::launch::deferred</code>：它是默认行为。使用此启动策略，它可以异步运行或不异步运行，具体取决于系统上的负载。但是我们无法控制它。</li></ul><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>假设我们必须从数据库中获取一些数据（字符串），并从文件系统中的文件中获取一些数据。然后，我需要合并两个字符串并进行打印。</p><p>在单线程中，我们这样做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromDB</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理创建数据库连接、获取数据等事情</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromFile</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理获取文件数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 获取开始时间</span><br>std::chrono::system_clock::time_point start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-comment">// 从数据库获取数据</span><br>std::string dbData = <span class="hljs-built_in">fetchDataFromDB</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">// 从文件获取数据</span><br>std::string fileData = <span class="hljs-built_in">fetchDataFromFile</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">// 获取结束时间</span><br><span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 计算消耗时间</span><br><span class="hljs-keyword">auto</span> diff = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 组装数据</span><br>std::string data = dbData + <span class="hljs-string">&quot; :: &quot;</span> + fileData;<br><span class="hljs-comment">// 输出组装的数据</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Total Time Taken  = 10 Seconds</span><br><span class="hljs-comment">Data = DB_Data :: File_Data</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>由于两个函数<code>fetchDataFromDB()</code>和<code>fetchDataFromFile()</code>均需要 5 秒钟，并且都在单个线程中运行，因此，消耗的总时间将为 10 秒钟。</p><p>现在，从数据库和文件中获取数据是彼此独立的，而且非常耗时。因此，我们可以并行运行它们。有两种方法：</p><p>一种方式是创建一个新的线程传递一个<code>promise</code>作为线程函数的参数，并在调用线程中从关联的<code>std::future</code>对象获取数据。<br>另一种简单的方法是使用<code>std::async</code>。</p><h2 id="使用函数指针调用std-async作为回调"><a href="#使用函数指针调用std-async作为回调" class="headerlink" title="使用函数指针调用std::async作为回调"></a>使用函数指针调用std::async作为回调</h2><p>现在让我们修改上面的代码，并使用<code>std::async</code>异步调用<code>fetchDataFromDB()</code>，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::future&lt;std::string&gt;resultFromDB = std::<span class="hljs-built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="hljs-string">&quot;Data&quot;</span>);<br><br>std::string dbData = resultDromDB.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><p><code>std::async()</code>做以下事情：</p><ul><li>它会自动为我们创建一个线程（或从内部线程池中选择）和一个 <code>promise</code> 对象。</li><li>然后将 <code>std::promise</code> 对象传递给线程函数，并返回关联的 <code>std::future</code> 对象。</li><li>当我们传递的参数函数退出时，其值将在此 <code>promise</code> 对象中设置，因此最终返回值将在 <code>std::future</code> 对象中可用。<br>现在更改上面的示例，并使用<code>std::async</code>从数据库异步读取数据，即：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromDB</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理创建数据库连接、获取数据等事情</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetchDataFromFile</span><span class="hljs-params">(std::string recvData)</span> </span>&#123;<br><span class="hljs-comment">// 确保函数要5秒才能执行完成</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 处理获取文件数据</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvData;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//获取开始时间</span><br>std::chrono::system_clock::time_point start = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-comment">// 创建异步线程，从数据库获取数据</span><br>std::future&lt;std::string&gt; resultFromDB = std::<span class="hljs-built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="hljs-string">&quot;Data&quot;</span>);<br><span class="hljs-comment">//从文件获取数据</span><br>std::string fileData = <span class="hljs-built_in">fetchDataFromFile</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><br><span class="hljs-comment">//从DB获取数据</span><br><span class="hljs-comment">//数据在future&lt;std::string&gt;对象中可获取之前，将一直阻塞</span><br>std::string dbData = resultFromDB.<span class="hljs-built_in">get</span>();<br><span class="hljs-comment">//获取结束时间</span><br><span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 计算消耗时间</span><br><span class="hljs-keyword">auto</span> diff = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time taken= &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot;Seconds&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 组装数据</span><br>std::string data = dbData + <span class="hljs-string">&quot; :: &quot;</span> + fileData;<br><span class="hljs-comment">// 输出组装的数据</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Total Time Taken  = 5 Seconds</span><br><span class="hljs-comment">Data = DB_Data :: File_Data</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>因为有一个任务是异步的，在 5 秒内可以同时执行完两个任务。</li></ul><h2 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h2><p><code>std::async</code>使用一个 <code>callable</code> 作为一个工作包。在本例中，它可以是个函数、函数对象或者匿名函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function">std::string <span class="hljs-title">helloFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloFunctionObject</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::string <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 带函数的future</span><br><span class="hljs-keyword">auto</span> futureFunction = std::<span class="hljs-built_in">async</span>(helloFunction, <span class="hljs-string">&quot;function&quot;</span>);<br><br><span class="hljs-comment">// 带函数对象的future</span><br>HelloFunctionObject helloFunctionObject;<br><span class="hljs-keyword">auto</span> futureFunctionObject = std::<span class="hljs-built_in">async</span>(helloFunctionObject, <span class="hljs-string">&quot;function object&quot;</span>);<br><br><span class="hljs-comment">// 带匿名函数的future</span><br><span class="hljs-keyword">auto</span> futureLambda = std::<span class="hljs-built_in">async</span>([](<span class="hljs-type">const</span> std::string&amp; s) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello C++11 from &quot;</span> + s + <span class="hljs-string">&quot;.&quot;</span>; &#125;, <span class="hljs-string">&quot;lambda function&quot;</span>);<br><br>std::cout &lt;&lt; futureFunction.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>&lt;&lt; futureFunctionObject.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span><br>&lt;&lt; futureLambda.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>std::cout &lt;&lt; std::endl;<br><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出：</span><br><span class="hljs-comment">Hello C++11 from function.</span><br><span class="hljs-comment">Hello C++11 from function object.</span><br><span class="hljs-comment">Hello C++11 from lambda function.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>std::async</code>调用在两端的 <code>future</code>和 <code>promise</code> 创建了一个数据通道。通过 <code>future</code> 的 <code>get()</code> 调用，<code>future</code> 收到了它的工作包的返回值。</p><p>std::async也可以绑定类成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//myClass的一个实例</span><br>    myClass obj;<br><br>　　 <span class="hljs-comment">//利用std::bind绑定类的成员函数</span><br>    <span class="hljs-keyword">auto</span> func = std::<span class="hljs-built_in">bind</span>(&amp;myClass::test, obj);<br>　　　<span class="hljs-comment">//构造future对象</span><br>    std::future&lt;<span class="hljs-type">bool</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, func);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;please wait&quot;</span>;<br>    std::<span class="hljs-function">chrono::milliseconds <span class="hljs-title">span</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (fut.<span class="hljs-built_in">wait_for</span>(span) != std::future_status::ready)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>    std::cout &lt;&lt; std::endl;<br>    <span class="hljs-type">bool</span> rtn = fut.<span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;final result: &quot;</span> &lt;&lt; rtn &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11 多线程与异步调用</title>
    <link href="/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    <url>/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://yilingui.xyz/wiki/c++/cxx11_multi_thread_and_async.html">https://yilingui.xyz/wiki/c++/cxx11_multi_thread_and_async.html</a></p></blockquote><h1 id="C-11-多线程与异步调用"><a href="#C-11-多线程与异步调用" class="headerlink" title="C++11 多线程与异步调用"></a>C++11 多线程与异步调用</h1><h2 id="使用C-11线程"><a href="#使用C-11线程" class="headerlink" title="使用C++11线程"></a>使用C++11线程</h2><p>&lt;thread&gt;是 C++11 的线程库，构造函数可以传入 function pointer\functor\lambda：</p><p>使用 std::this_thread::get_id() 可以获取当前线程的 ID 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_func1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_id = std::this_thread::<span class="hljs-built_in">get_id</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;thread_func1, id: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// thread 可以接受 function pointer/functor/lambda</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func1)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">auto</span> thread_id = std::this_thread::get_id();</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;thread func lambda, id: &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::endl;<br><br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程的join和detach"><a href="#线程的join和detach" class="headerlink" title="线程的join和detach"></a>线程的join和detach</h2><p>join() 的含义就是等待线程完成工作，然后 join 回到当前线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func_ptr)</span></span>;<br><br>  <span class="hljs-comment">// do something (main thread)</span><br><br>  t1.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// wait thread t1 to finish its job</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，t1.join() 就是等待 t1 线程完成，然后才会继续当前线程的操作。</p><p>可以用 <code>std::this_thread::sleep_for()</code> 让线程等待一定时间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;before start thread t1\n&quot;</span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">200</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      ++i;</span></span><br><span class="hljs-params"><span class="hljs-function">      <span class="hljs-comment">// sleep 10 ms per iteration</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">      std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">10</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;   </span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;t1 finished.\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>; <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;do something in main thread.\n&quot;</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;wait t1 to finish.\n&quot;</span>;<br>  <span class="hljs-comment">// 主线程什么都没做，但是由于调用了 t1.join()，需要等待 t1 线程完成任务</span><br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;done.\n&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以一次创建多个线程，用一个 vector保存，注意下面 std::mem_fn 的作用是将一个类的成员函数包装成一个参数为对象的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>                                                                                                                                                                                         </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>  &#125;;<br>  std::vector&lt;std::thread&gt; thread_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(thread_func));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;wait for all the worker thread to finish.\n&quot;</span>;<br>  std::for_each(thread_list.<span class="hljs-built_in">begin</span>(), thread_list.<span class="hljs-built_in">end</span>(),<br>                std::<span class="hljs-built_in">mem_fn</span>(&amp;std::thread::join));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>detach 的作用是创建分离线程&#x2F;后台线程&#x2F;守护线程：</p><blockquote><p>Detached threads are also called daemon &#x2F; Background threads.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>t1.<span class="hljs-built_in">detach</span>();  <span class="hljs-comment">// After calling detach(), std::thread object</span><br>              <span class="hljs-comment">// is no longer associated with the actual thread of execution.</span><br></code></pre></td></tr></table></figure><ul><li>join是阻塞当前线程，并等待 thread object 对应的线程结束，当前线程继续执行</li><li>detach 是将线程从当前线程分离出去，即不受阻塞，操作系统会将其独立对待</li></ul><p>使用 <code>detach()</code> 函数会让线程在后台运行，即说明 主线程不会等待子线程运行结束才结束 。</p><p>通常称分离线程为守护线程(daemon threads), UNIX中守护线程是指，没有任何显式的用户接口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));                     <br>    &#125;<br>  &#125;;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func)</span></span>;<br>  t1.<span class="hljs-built_in">detach</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// main thread finished.</span><br><span class="hljs-comment">// thread id: 140529165158144</span><br><span class="hljs-comment">// 可以看到主线程没有等待 t1 线程完成就结束了</span><br></code></pre></td></tr></table></figure><p>要注意，一旦调用 join() 或者 detach()，那么线程对象就不再与实际线程有关联了，要避免重复调用 join() &#x2F; detach() 。</p><p>可以用 joinable() 判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func1)</span></span>;<br><span class="hljs-keyword">if</span>(t1.<span class="hljs-built_in">joinable</span>()) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Detaching Thread.&quot;</span> &lt;&lt; std::endl;<br>  t1.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func2)</span></span>;<br><span class="hljs-keyword">if</span>(t2.<span class="hljs-built_in">joinable</span>()) &#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Joining Thread.&quot;</span> &lt;&lt; std::endl;<br>  t2.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一点要注意，不要忘记调用线程对象的 join() &#x2F; detach() 而直接 return:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> thread_func = []() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    &#125;<br>  &#125;;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_func)</span></span>;<br>  <span class="hljs-comment">// Program will terminate as we have&#x27;t called either join or detach with the std::thread object.</span><br>  <span class="hljs-comment">// Hence std::thread&#x27;s object destructor will terminate the program</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread finished.\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 RAII(Resource Acquisition Is Initialization) 对 thread 进行封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadRAII</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ThreadRAII</span>(std::thread &amp;t) : <span class="hljs-built_in">t_</span>(t) &#123;&#125;<br>  ~<span class="hljs-built_in">ThreadRAII</span>() &#123;<br>    <span class="hljs-keyword">if</span> (t_.<span class="hljs-built_in">joinable</span>()) &#123;<br>      t_.<span class="hljs-built_in">detach</span>();<br>    &#125;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::thread&amp; t_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;thread id: &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  <span class="hljs-function">ThreadRAII <span class="hljs-title">wrapper_t</span><span class="hljs-params">(t)</span></span>;  <span class="hljs-comment">// If we comment this Line, then program will crash</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传递参数给线程"><a href="#传递参数给线程" class="headerlink" title="传递参数给线程"></a>传递参数给线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> std::string &amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>  std::string str = <span class="hljs-string">&quot;hello, world&quot;</span>;<br><br>  <span class="hljs-comment">// directly pass params to std::thread&#x27;s constructor</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, x, str)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，小心传递局部变量或者动态内存的地址和指针，不同线程难以保证指针是否有效。对于真正要共享的内容，要记得 加锁 。</p><h3 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h3><p>默认传参给线程会拷贝一份参数的值到线程，即使声明了引用参数也无法改变外部变量，如何传递引用？可以用 <code>std::ref()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> &amp;y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(x);  <span class="hljs-comment">// 强制转换为非 const</span><br>  ++y;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inside thread x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, before t1 starts, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, x)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, after t1 joins, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main thread, before t1 starts, x: 9</span><br><span class="hljs-comment">inside thread x: 10</span><br><span class="hljs-comment">main thread, after t1 joins, x: 9</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 可以看到，即使声明了引用参数，也没有改变 main thread 中 x 的值</span><br></code></pre></td></tr></table></figure><p>使用 <code>std::ref</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>  <span class="hljs-type">int</span> &amp;y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(x);  <span class="hljs-comment">// 强制转换为非 const</span><br>  ++y;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;inside thread x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-type">int</span> x = <span class="hljs-number">9</span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, before t1 starts, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread_callback, std::ref(x))</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;main thread, after t1 joins, x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main thread, before t1 starts, x: 9</span><br><span class="hljs-comment">inside thread x: 10</span><br><span class="hljs-comment">main thread, after t1 joins, x: 10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="传递成员函数"><a href="#传递成员函数" class="headerlink" title="传递成员函数"></a>传递成员函数</h3><p>成员函数传递给线程，注意第一个函数参数要传实例的地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_hello</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;str)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, &quot;</span> &lt;&lt; str &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  A a;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;A::say_hello, &amp;a, <span class="hljs-string">&quot;stranger&quot;</span>)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Lock-机制处理多线程数据共享"><a href="#使用-Lock-机制处理多线程数据共享" class="headerlink" title="使用 Lock 机制处理多线程数据共享"></a>使用 Lock 机制处理多线程数据共享</h2><h3 id="Race-condition"><a href="#Race-condition" class="headerlink" title="Race condition"></a>Race condition</h3><blockquote><p>Race condition is a kind of a bug that occurs in multithreaded applications.  </p></blockquote><p>多个线程并发地访问同一个地址时，如果不做一些特殊处理，可能会引发意想不到的结果。</p><h3 id="Lock-机制"><a href="#Lock-机制" class="headerlink" title="Lock 机制"></a>Lock 机制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Count</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 多线程写操作，要加锁</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    mutex_for_x_.<span class="hljs-built_in">lock</span>();<br>    ++x_;<br>    mutex_for_x_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reduce</span><span class="hljs-params">()</span> </span>&#123;<br>    mutex_for_x_.<span class="hljs-built_in">lock</span>();<br>    --x_;<br>    mutex_for_x_.<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_count</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x_;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x_ = <span class="hljs-number">0</span>;<br>  std::mutex mutex_for_x_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Count count;<br>  std::vector&lt;std::thread&gt; thread_list;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>      thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Count::add, &amp;count));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      thread_list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(&amp;Count::reduce, &amp;count));<br>    &#125;<br>  &#125;<br>  std::for_each(thread_list.<span class="hljs-built_in">begin</span>(), thread_list.<span class="hljs-built_in">end</span>(),<br>      std::<span class="hljs-built_in">mem_fn</span>(&amp;std::thread::join));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;final count: &quot;</span> &lt;&lt; count.<span class="hljs-built_in">get_count</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用 std::lock_guard，实现了对 mutex 对象的 RAII：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// lock_guard 对象出作用域会自动 unlock mutex</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_for_x_)</span></span>;<br>    ++x_;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="使用-Condition-variable-处理事件响应"><a href="#使用-Condition-variable-处理事件响应" class="headerlink" title="使用 Condition variable 处理事件响应"></a>使用 Condition variable 处理事件响应</h2><p>假设要实现一个简单的消费者生产者模型，一个线程往队列中放入数据，一个线程从队列中取数据，取数据前需要判断一下队列中确实有数据，由于这个队列是线程间共享的，所以，需要使用互斥锁进行保护，一个线程在往队列添加数据的时候，另一个线程不能取，反之亦然。</p><p>mutex 可以完成这个任务，但是却存在着性能问题。消费者每次都要等待锁释放。如果生产者处理开销较大，那么会有不必要的等待开销。</p><p>更合适的模型是，生产者往队列中添加完数据后，立刻通知消费者干活，如何实现这种“通知”的机制？C++11 提供了 Condition variable 来帮我们实现多线程之间的 signal 机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Application</span>() = <span class="hljs-keyword">default</span>;<br>  ~<span class="hljs-built_in">Application</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load_data</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;loading data...\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    <span class="hljs-comment">// lock the data</span><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    data_loaded_ = <span class="hljs-literal">true</span>;<br>    cond_var_.<span class="hljs-built_in">notify_one</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main_proc</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main processing...\n&quot;</span>;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-comment">// Start waiting for the Condition Variable to get signaled</span><br>    <span class="hljs-comment">// wait() will internally release the lock and make the thread to block</span><br>    <span class="hljs-comment">// as soon as condition variable get signaled, resume the thread and</span><br>    <span class="hljs-comment">// again acquire the lock. Then check if condition is met or not</span><br>    <span class="hljs-comment">// if condition is met then continue else again go in wait.</span><br>    cond_var_.<span class="hljs-built_in">wait</span>(lock, [&amp;]() &#123;<br>      <span class="hljs-keyword">return</span> data_loaded_;<br>    &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;main processing done.\n&quot;</span>;<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">bool</span> data_loaded_ = <span class="hljs-literal">false</span>;<br>  std::mutex mutex_;<br>  std::condition_variable cond_var_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Application app;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(&amp;Application::load_data, &amp;app)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(&amp;Application::main_proc, &amp;app)</span></span>;<br>  t2.<span class="hljs-built_in">join</span>();<br>  t1.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>cond_var_.wait()</code> 要和 <code>std::unique_lock</code> 配合使用，不能用 <code>std::lock_guard</code>，因为 <code>wait()</code> 函数会先调用互斥锁的 <code>unlock()</code> 函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而 <code>lock_guard</code> 没有 <code>lock</code> 和 <code>unlock</code> 接口，而 <code>unique_lock</code> 提供了。这就是必须使用 <code>unique_lock</code> 的原因。</p><p>关于 std::condition_variable 的成员函数：</p><blockquote><ul><li>wait()：It makes the current thread to block until the condition variable get signaled or a spurious wake up happens.</li><li>notify_one()：If any threads are waiting on same conditional variable object then notify_one unblocks one of the waiting threads.</li><li>notify_all()：If any threads are waiting on same conditional variable object then notify_all unblocks all of the waiting threads.</li></ul></blockquote><p>再看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>std::deque&lt;<span class="hljs-type">int</span>&gt; q;<br>std::mutex mu;<br>std::condition_variable cond;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>    q.<span class="hljs-built_in">push_front</span>(count);<br>    locker.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 注意控制锁的粒度，q.push_front() 之后就不需要保护了，可以提前 unlock</span><br>    cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">// Notify one waiting thread, if there is one.</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    --count;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( data != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">locker</span><span class="hljs-params">(mu)</span></span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">empty</span>()) &#123;<br>      cond.<span class="hljs-built_in">wait</span>(locker); <span class="hljs-comment">// Unlock mutex and wait to be notified</span><br>    &#125;<br>    data = q.<span class="hljs-built_in">back</span>();<br>    q.<span class="hljs-built_in">pop_back</span>();<br>    locker.<span class="hljs-built_in">unlock</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;t2 got a value from t1: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(function_1)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(function_2)</span></span>;<br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-std-future-和-std-promise-处理线程的返回值"><a href="#使用-std-future-和-std-promise-处理线程的返回值" class="headerlink" title="使用 std::future 和 std::promise 处理线程的返回值"></a>使用 std::future 和 std::promise 处理线程的返回值</h2><p>假设我们要写一个程序，从主线程创建一个线程来压缩一个文件夹，压缩完成后在主线程打印压缩文件名和大小，要求压缩线程返回压缩文件名和文件大小。</p><p>第一种方式：通过共享指针实现，向压缩线程传入一个指针变量，利用 mutex，condition variable 完成。</p><p>第二种方式：使用 std::future 和 std::promise。</p><blockquote><ul><li>std::future is a class template and its object stores the future value .</li><li>std::promise is also a class template and its object promises to set the value in future . Each std::promise object has an associated std::future object that will give the value once set by the std::promise object.</li><li>A std::promise object shares data with its associated std::future object.</li></ul></blockquote><p>如图所示：</p><img src="/2023/12/28/C-11-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/cxx11_promise_future.png" class="" title="cxx11_promise_future"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; * promise_obj)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Inside Thread&quot;</span> &lt;&lt; std::endl;<br>  promise_obj-&gt;<span class="hljs-built_in">set_value</span>(<span class="hljs-number">42</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  std::promise&lt;<span class="hljs-type">int</span>&gt; promise_obj;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; future_obj = promise_obj.<span class="hljs-built_in">get_future</span>();<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(init, &amp;promise_obj)</span></span>;<br>  std::cout &lt;&lt; future_obj.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// blocked on the std::future::get() function</span><br>  t.<span class="hljs-built_in">join</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-11-异步调用"><a href="#C-11-异步调用" class="headerlink" title="C++11 异步调用"></a>C++11 异步调用</h2><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h3><p>异步操作的主要目的是 让调用方法的主线程不需要同步等待调用函数，从而可以让主线程继续执行它下面的代码 。因此异步操作无须额外的线程负担，使用回调的方式进行处理。在设计良好的情况下，处理函数可以不必或者减少使用共享变量，减少了死锁的可能。当需要执行I&#x2F;O操作时，使用异步操作比使用线程+同步I&#x2F;O操作更合适。</p><p>异步和多线程并不是一个同等关系， 异步是目的，多线程是实现异步的一个手段 。实现异步可以采用多线程或交给另外的进程来处理。</p><ul><li>std::future 可以从异步任务中获取结果，一般与 std::async 配合使用， std::async 用于创建异步任务，实际上就是创建一个线程执行相应任务。</li><li>std::async 就是异步编程的高级封装，封装了 std::future 的操作，基本上可以代替 std::thread 的所有事情</li><li>std::async 的操作，其实相当于封装了 std::promise 、 std::packaged_task 加上 std::thread 。<blockquote><p>std::async： std::async() is a function template that accepts a callback(i.e. function or function object) as an argument and potentially executes them asynchronously.</p></blockquote></li></ul><p>std::async 的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>future&lt;<span class="hljs-keyword">typename</span> result_of&lt;<span class="hljs-built_in">Fn</span>(Args...)&gt;::type&gt; <span class="hljs-built_in">async</span> (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><blockquote><p>std::async returns a std::future<T>, that stores the value returned by function object executed by std::async(). Arguments expected by function can be passed to std::async() as arguments after the function pointer argument.<br>First argument in std::async is launch policy, it control the asynchronous behaviour of std::async .</p></blockquote><ul><li>std::launch::async ，调用即创建线程，在另一个 thread 中执行任务</li><li>std::launch::deferred ，延迟加载方式创建线程，调用时不创建线程，直到调用 future 的 get 或者 wait 时才创建线程(lazy evaluation)</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_data_from_db</span><span class="hljs-params">(std::string recvd_data)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DB_&quot;</span> + recvd_data;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">fetch_data_from_file</span><span class="hljs-params">(std::string recvd_data)</span> </span>&#123;<br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-built_in">seconds</span>(<span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;File_&quot;</span> + recvd_data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  system_clock::time_point start = system_clock::<span class="hljs-built_in">now</span>();<br><br>  <span class="hljs-comment">// 异步调用，std::launch::async 策略，会立即创建一个线程工作</span><br>  <span class="hljs-comment">// 如果改成 std::launch::deferred，那么这个例子就看不到使用异步加速的效果了</span><br>  std::future&lt;std::string&gt; result_from_db =<br>      std::<span class="hljs-built_in">async</span>(std::launch::async, fetch_data_from_db, <span class="hljs-string">&quot;Data&quot;</span>);<br><br>  <span class="hljs-comment">// Fetch Data from File</span><br>  std::string file_data = <span class="hljs-built_in">fetch_data_from_file</span>(<span class="hljs-string">&quot;Data&quot;</span>);<br><br>  <span class="hljs-comment">// Fetch Data from DB</span><br>  <span class="hljs-comment">// Will block till data is available in future&lt;std::string&gt; object.</span><br>  std::string db_data = result_from_db.<span class="hljs-built_in">get</span>();<br><br>  <span class="hljs-keyword">auto</span> end = system_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-keyword">auto</span> diff = duration_cast &lt; std::chrono::seconds &gt; (end - start).<span class="hljs-built_in">count</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Total Time Taken = &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&quot; Seconds&quot;</span> &lt;&lt; std::endl;<br>  std::string data = db_data + <span class="hljs-string">&quot; :: &quot;</span> + file_data;<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Data = &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>std::promise 通过 set_value 可以使得与之关联的 std::future 获取数据。 std::packaged_task 则更为强大，它允许传入一个函数，并将函数计算的结果传递给 std::future。</p><p>std::packaged_task&lt;&gt; is a class template and represents a asynchronous task. It encapsulates:</p><ul><li>A callable entity i.e either function, lambda function or function object.</li><li>A shared state that stores the value returned or thrown exception by associated callback.</li></ul><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(sum)</span></span>;<br>  std::future&lt;<span class="hljs-type">int</span>&gt; future = task.<span class="hljs-built_in">get_future</span>();<br><br>  <span class="hljs-comment">// std::promise 一样，std::packaged_task 支持 move，但不支持拷贝</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(std::move(task), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-comment">// 等待异步计算结果</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;1 + 2 =&gt; &quot;</span> &lt;&lt; future.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br><br>  t.<span class="hljs-built_in">join</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-std-future-和-std-promise-实现终止线程功能"><a href="#使用-std-future-和-std-promise-实现终止线程功能" class="headerlink" title="使用 std::future 和 std::promise 实现终止线程功能"></a>使用 std::future 和 std::promise 实现终止线程功能</h2><p>我们希望能显式控制一个进程的终止，该如何实现？前面提到过了 std::promise 和 std::future，只有当 promise 设置值的时候 future 才会真正获取值，那么可以把 promise::set_value 作为一个通知信号来使用，，检查 future 的状态就知道是不是要结束线程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_callback</span><span class="hljs-params">(std::future&lt;<span class="hljs-type">void</span>&gt; future_obj)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread Start&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 利用 std::future::wait_for() 来控制循环是否终止</span><br>  <span class="hljs-comment">// 如果相应的 promise object 调用了 set_value()，那么结束循环</span><br>  <span class="hljs-keyword">while</span> (future_obj.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">0</span>)) ==<br>      std::future_status::timeout) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Doing Some Work&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread End&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-comment">// Create a std::promise object</span><br>  std::promise&lt;<span class="hljs-type">void</span>&gt; exit_signal;<br><br>  <span class="hljs-comment">// Fetch std::future object associated with promise</span><br>  std::future&lt;<span class="hljs-type">void</span>&gt; future_obj = exit_signal.<span class="hljs-built_in">get_future</span>();<br><br>  <span class="hljs-comment">// Starting Thread &amp; move the future object in lambda function by reference</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;thread_callback, std::move(future_obj))</span></span>;<br><br>  <span class="hljs-comment">// Wait for 10 sec</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Asking Thread to Stop&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// Set the value in promise</span><br>  exit_signal.<span class="hljs-built_in">set_value</span>();<br><br>  <span class="hljs-comment">// Wait for thread to join</span><br>  t.<span class="hljs-built_in">join</span>();<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting Main Function&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用面向对象封装一个 Stoppable 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stoppable</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Stoppable</span>() : <span class="hljs-built_in">future_obj_</span>(exit_signal_.<span class="hljs-built_in">get_future</span>()) &#123;&#125;<br>  <span class="hljs-built_in">Stoppable</span>(Stoppable &amp;&amp;obj) : <span class="hljs-built_in">exit_signal_</span>(std::<span class="hljs-built_in">move</span>(obj.exit_signal_)),<br>      <span class="hljs-built_in">future_obj_</span>(std::<span class="hljs-built_in">move</span>(obj.future_obj_)) &#123;&#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stoppable</span>() = <span class="hljs-keyword">default</span>;<br><br>  Stoppable&amp; <span class="hljs-keyword">operator</span>=(Stoppable &amp;&amp;obj) &#123;<br>    exit_signal_ = std::<span class="hljs-built_in">move</span>(obj.exit_signal_);<br>    future_obj_ = std::<span class="hljs-built_in">move</span>(obj.future_obj_);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">run</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_stop_requested</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (future_obj_.<span class="hljs-built_in">wait_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">0</span>)) ==<br>        std::future_status::timeout) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>    exit_signal_.<span class="hljs-built_in">set_value</span>();<br>  &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::promise&lt;<span class="hljs-type">void</span>&gt; exit_signal_;<br>  std::future&lt;<span class="hljs-type">void</span>&gt; future_obj_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> : <span class="hljs-keyword">public</span> Stoppable &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task Start&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">is_stop_requested</span>()) &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Doing Some Work&quot;</span> &lt;&lt; std::endl;<br>      std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1000</span>));<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task End&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  MyTask task;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    task.run();</span></span><br><span class="hljs-params"><span class="hljs-function">  &#125;)</span></span>;<br><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">10</span>));<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Asking Task to Stop&quot;</span> &lt;&lt; std::endl;<br>  task.<span class="hljs-built_in">stop</span>();<br>  t.<span class="hljs-built_in">join</span>();<br><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Thread Joined&quot;</span> &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Exiting Main Function&quot;</span> &lt;&lt; std::endl;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<img src="/2023/12/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/mario.jpeg" class="" title="mario">]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mario</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
